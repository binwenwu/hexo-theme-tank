{"meta":{"title":"Tankenqiの小窝","subtitle":"","description":null,"author":"Tankenqi","url":"https://binwenwu.github.io","root":"/"},"pages":[{"title":"","date":"2025-05-17T05:51:06.628Z","updated":"2025-05-17T05:51:06.628Z","comments":true,"path":"link.json","permalink":"https://binwenwu.github.io/link.json","excerpt":"","text":"{\"link_list\":[],\"length\":0}"},{"title":"","date":"2025-05-17T05:51:06.628Z","updated":"2025-05-17T05:51:06.628Z","comments":true,"path":"manifest.json","permalink":"https://binwenwu.github.io/manifest.json","excerpt":"","text":"{\"name\":\"Tankenqiの小窝\",\"short_name\":\"Tankenqiの小窝\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2025-05-17T05:51:06.628Z","updated":"2025-05-17T05:51:06.628Z","comments":true,"path":"package.json","permalink":"https://binwenwu.github.io/package.json","excerpt":"","text":"{\"name\":\"tankenqiblog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"bangumis","date":"2022-07-16T02:35:32.000Z","updated":"2025-05-17T05:51:06.591Z","comments":true,"path":"bangumis/index.html","permalink":"https://binwenwu.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-03-30T07:57:51.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"about/index.html","permalink":"https://binwenwu.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-03T12:48:08.000Z","updated":"2025-05-17T05:51:06.591Z","comments":true,"path":"categories/index.html","permalink":"https://binwenwu.github.io/categories/index.html","excerpt":"","text":""},{"title":"自建GPT，需要魔法访问，通过密码或者自己的key来进行使用)","date":"2025-05-17T05:51:06.591Z","updated":"2025-05-17T05:51:06.591Z","comments":false,"path":"chatgpt/index.html","permalink":"https://binwenwu.github.io/chatgpt/index.html","excerpt":"","text":"`"},{"title":"","date":"2025-05-17T05:51:06.591Z","updated":"2025-05-17T05:51:06.591Z","comments":false,"path":"eat_cats/index.html","permalink":"https://binwenwu.github.io/eat_cats/index.html","excerpt":"","text":""},{"title":"fontawesome对照","date":"2022-11-25T00:16:09.000Z","updated":"2025-05-17T05:51:06.591Z","comments":true,"path":"fontawesome/index.html","permalink":"https://binwenwu.github.io/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"朋友圈","date":"2023-01-29T07:23:17.000Z","updated":"2025-05-17T05:51:06.591Z","comments":true,"path":"fcircle/index.html","permalink":"https://binwenwu.github.io/fcircle/index.html","excerpt":"","text":"🎣 钓鱼 与主机通讯中…… var fdataUser = { apiurl: 'https://hexo-circle-of-friends-eight-dun.vercel.app/' }"},{"title":"小空调","date":"2022-11-24T23:37:35.000Z","updated":"2025-05-17T05:51:06.627Z","comments":true,"path":"kongtiao/index.html","permalink":"https://binwenwu.github.io/kongtiao/index.html","excerpt":"","text":""},{"title":"声明","date":"2023-07-10T03:13:49.000Z","updated":"2025-05-17T05:51:06.627Z","comments":true,"path":"license/index.html","permalink":"https://binwenwu.github.io/license/index.html","excerpt":"","text":"Copyright© TANKENQI 2023 声明 | 版权协议 为了保持文章质量，并保持互联网的开放共享精神，保持页面流量的稳定，综合考虑下本站的所有原创文章均采用cc协议中比较严格的创作共用-非商业性-禁止演绎 4.0 国际标准。这篇文章主要想能够更加清楚明白的介绍本站的协议标准和要求。方便您合理的使用本站的文章。 本站无广告嵌入和商业行为。违反协议的行为不仅会损害原作者的创作热情，而且会影响整个版权环境。强烈呼吁您能够在转载时遵守协议。遵守协议的行为几乎不会对您的目标产生负面影响，鼓励创作环境是每个创作者的期望。 博客的分类介绍 经验分享包含原创内容，原创内容的非商用转载必须为完整转载且标注出处的带有超链接功能的完整url链接（需能点击）或访问原文之类字样的超链接。 转载内容为转载内容，均标注了出处。建议使用原链接打开，尊重原作者。所有转载内容尽可能为完整转载（如果有部分内容有问题可能会由部分删减和补充）并进行样式调整以适合本博客。如果转载该部分内容需要联系原作者。 你可以做什么？ 只要您遵守本页的许可，您可以自由地共享文章的内容 — 在任何媒介以任何形式复制、发行本作品。并且无需通知作者。 你需要遵守什么样的许可？ 署名 您必须标注内容的来源，您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接提升阅读体验）。 禁止商用 本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用、禁止在转载页面中插入广告（例如谷歌广告、百度广告）、禁止阅读的拦截行为（例如关注公众号、下载App后观看文章）。 禁止演绎 分享全部内容（无修改） 您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接） 分享部分截取内容或者衍生创作 目前本站全部原创文章的衍生品禁止公开分享和分发。如有更好的修改建议，可以在对应文章下留言。如有衍生创作需求，可以在评论中联系。 什么内容会被版权保护 包括但不限于： 文章封面图片 文章标题和正文 站点图片素材（不含主题自带素材） 例外情况 本着友好互相进步的原则，被本站友链收录的博客允许博客文章内容的衍生品的分享和分发，但仍需标注出处。 本着互联网开放精神，您可以在博客文章下方留言要求授权博文的衍生品的分享和分发，标注您的网站地址。 作者原创代码及网站源代码协议 网站所有代码采用MIT协议，如有不同，作者会进行标注 随便扒站吧！ 网站本身有关 本站已开启存储桶全站加速，接入了灵天盾CDN，请刷流量的耗子尾汁！！！"},{"title":"友链","date":"2023-07-03T12:40:57.000Z","updated":"2025-05-17T05:51:06.628Z","comments":true,"path":"links/index.html","permalink":"https://binwenwu.github.io/links/index.html","excerpt":"","text":"🎣 钓鱼 冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来 开发基础没有这些框架，哪来这博客呢？ Hexo 快速、简单且强大的网站框架 Butterfly 美观、方便的Hexo主题 推荐博客一些作者推荐的友链 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来 Tianli 惟其不可能，所以才相信 小N同学 青石落晚巷 故人未还乡 轻笑Chuckle 宁静致远,倾尘轻笑 Leonus 进一寸有进一寸的欢喜 专业相关一些和专业相关的博客 BimAnt 3D + AI 岭南灯火 GISer 朋友那些人，那些事 forDece 一枚优秀的学弟 Zly 记录，让你的人生不后悔 我的信息 Butterfly & MengDfluidvolantishtml12345- name: Tankenqiの小窝 link: https://www.tankenqi.cn avatar: https://cdn.jsdelivr.net/gh/binwenwu/picgo_demo/img/639a9ebbbc1ad.webp descr: 大快朵颐 siteshot: https://cdn.jsdelivr.net/gh/binwenwu/picgo_demo/img/blog.png123456- &#123; title: &#x27;Tankenqiの小窝&#x27;, intro: &#x27;大快朵颐&#x27;, link: &#x27;https://www.tankenqi.cn&#x27;, image: &#x27;https://cdn.jsdelivr.net/gh/binwenwu/picgo_demo/img/639a9ebbbc1ad.webp&#x27;&#125;123456- title: Tankenqiの小窝 avatar: https://cdn.jsdelivr.net/gh/binwenwu/picgo_demo/img/639a9ebbbc1ad.webp url: https://www.tankenqi.cn screenshot: https://cdn.jsdelivr.net/gh/binwenwu/picgo_demo/img/blog.png keywords: 个人博客 description: 大快朵颐1&lt;a href=&quot;https://www.tankenqi.cn&quot;&gt;&lt;img src=&quot;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&quot; alt=&quot;avatar&quot;&gt;Tankenqiの小窝&lt;/a&gt; 推荐标签衡量标准 1.网站没有不良内容2.文章质量较高3.文章较多/或者质量过硬 如何申请友链？ 点下面的按钮！ 快速添加友链"},{"title":"音乐","date":"2025-05-17T05:51:06.628Z","updated":"2025-05-17T05:51:06.628Z","comments":false,"path":"music/index.html","permalink":"https://binwenwu.github.io/music/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-17T05:51:06.628Z","updated":"2025-05-17T05:51:06.628Z","comments":true,"path":"messageboard/index.html","permalink":"https://binwenwu.github.io/messageboard/index.html","excerpt":"","text":"说说你的建议吧... 你也可以私发我的邮件2390726421@qq.com寻求帮助或者提供建议。 隐藏/显示弹幕（缓解卡顿） document.title = '留言板 | Tankenqiの小窝';"},{"title":"敲木鱼","date":"2022-11-25T00:16:09.000Z","updated":"2025-05-17T05:51:06.628Z","comments":true,"path":"muyu/index.html","permalink":"https://binwenwu.github.io/muyu/index.html","excerpt":"","text":"功德：0 功德+100 .muyu-layout { background: black; display: flex; width: 100%; border-radius: 20px; position: relative; justify-content: center; height: 90vh; align-items: center; } #muyu-box img { width: 250px; } #jishu-box{ top: 55px; position: absolute; } #muyu-box p { color: white; opacity: 0; font-size: 25px; } #jishu-box p { color: white; font-size: 30px; } var gongde = document.getElementById(\"gongde\"); var muyu = document.getElementById(\"muyu\"); var jishu = document.getElementById(\"jishu-box\"); var mp3Url = \"/music/muyu.mp3\"; var player = new Audio(mp3Url); var num = 0; muyu.addEventListener(\"click\", function () { num+=100; player.load(); player.play(); muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500); gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600); jishu.innerHTML = \"功德：\"+num+\"\"; });"},{"title":"分站","date":"2023-08-04T03:38:05.000Z","updated":"2025-05-17T05:51:06.628Z","comments":true,"path":"othersite/index.html","permalink":"https://binwenwu.github.io/othersite/index.html","excerpt":"","text":"一些博主搭建的其它的站点(其实还没怎么开始搭)： PS：划掉的表示已挂 域名 用处 搭建原因 tankenqi.cn 博客，也是主站 分享一些东西 博主的一些域名 域名 用处 tankenqi.cn 主要使用的域名 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"说说","date":"2025-05-17T05:51:06.629Z","updated":"2025-05-17T05:51:06.629Z","comments":true,"path":"speaks/index.html","permalink":"https://binwenwu.github.io/speaks/index.html","excerpt":"","text":"function doSpeaks() { document.title = '说说 | Tankenqiの小窝'; bbtalk.init({ appId: \"4RerqbGfsYW0B6i3fFVRWPvv-MdYXbMMI\", appKey: \"CF1XA7YjaRWQpYI3fWsINeBg\", serverURL: \"https://4rerqbgf.api.lncldglobal.com\", pageSize:1919810 }) } document.addEventListener('DOMContentLoaded', (e) => { doSpeaks(); }) document.addEventListener('pjax:complete', (e) => { doSpeaks(); })"},{"title":"","date":"2025-05-17T05:51:06.629Z","updated":"2025-05-17T05:51:06.629Z","comments":true,"path":"stars/allStars.json","permalink":"https://binwenwu.github.io/stars/allStars.json","excerpt":"","text":"{\".mine\":[{\"nickname\":\"又拍云控制台\",\"site\":\"https://console.upyun.com/dashboard/\",\"content\":\"CDN管理，刷新CDN缓存\"},{\"nickname\":\"LeanCloud控制台\",\"site\":\"https://leancloud.cn/dashboard/applist.html#/apps\",\"content\":\"应用管理，数据控制\"},{\"nickname\":\"开课吧\",\"site\":\"https://appaadih2af2521.pc.xiaoe-tech.com/bought\",\"content\":\"学习网站\"},{\"nickname\":\"网易云课堂\",\"site\":\"https://study.163.com/my\",\"content\":\"学习网站\"},{\"nickname\":\"NexT\",\"site\":\"https://theme-next.org/docs/\",\"content\":\"NexT主题官方文档\"}],\".docs\":[{\"nickname\":\"JavaScript\",\"site\":\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference\",\"content\":\"JavaScript API 文档\"},{\"nickname\":\"HTML\",\"site\":\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element\",\"content\":\"HTML API 文档\"},{\"nickname\":\"CSS\",\"site\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference\",\"content\":\"CSS API 文档\"},{\"nickname\":\"Python\",\"site\":\"https://docs.python.org/\",\"content\":\"Python API 文档\"},{\"nickname\":\"PHP\",\"site\":\"https://www.php.net/manual/zh/index.php\",\"content\":\"PHP API 文档\"},{\"nickname\":\"SQL\",\"site\":\"https://docs.microsoft.com/zh-cn/sql/\",\"content\":\"SQL API 文档\"},{\"nickname\":\"Node.js\",\"site\":\"http://nodejs.cn/\",\"content\":\"Node.js API 文档\"},{\"nickname\":\"MongoDB\",\"site\":\"https://docs.mongodb.com/manual/\",\"content\":\"MongoDB API 文档\"},{\"nickname\":\"Vue.js\",\"site\":\"https://cn.vuejs.org/v2/guide/\",\"content\":\"一套用于构建用户界面的渐进式框架。\"},{\"nickname\":\"Vuex\",\"site\":\"https://vuex.vuejs.org/zh/\",\"content\":\"一个专为Vue.js应用程序开发的状态管理模式\"},{\"nickname\":\"Vue Router\",\"site\":\"https://router.vuejs.org/zh/\",\"content\":\"Vue.js官方路由管理器\"},{\"nickname\":\"Puppeteer中文文档\",\"site\":\"https://zhaoqize.github.io/puppeteer-api-zh_CN/\",\"content\":\"一个Node库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome。Puppeteer 默认以 headless 模式运行，但是可以通过修改配置文件运行“有头”模式。\"},{\"nickname\":\"axios中文文档\",\"site\":\"http://www.axios-js.com/\",\"content\":\"易用、简洁且高效的http库\"},{\"nickname\":\"Express中文文档\",\"site\":\"https://www.expressjs.com.cn/\",\"content\":\"基于Node.js平台，快速、开放、极简的Web开发框架\"},{\"nickname\":\"Layui\",\"site\":\"https://www.layui.com/\",\"content\":\"经典模块化前端UI框架\"}],\".code\":[{\"nickname\":\"Github\",\"site\":\"https://github.com/\",\"content\":\"全球最大的面向开源及私有软件项目的托管平台\"},{\"nickname\":\"Gitlab\",\"site\":\"https://gitlab.com/\",\"content\":\"支持无限的公有项目和私有项目的代码托管平台\"},{\"nickname\":\"Coding\",\"site\":\"https://coding.net/\",\"content\":\"国内首个一站式云端软件服务平台\"},{\"nickname\":\"Gitee\",\"site\":\"https://gitee.com/\",\"content\":\"国内最大的开源社区 OSChina 的代码托管平台\"},{\"nickname\":\"阿里云代码托管\",\"site\":\"https://code.aliyun.com/\",\"content\":\"阿里云旗下代码托管平台\"},{\"nickname\":\"百度效率云\",\"site\":\"http://xiaolvyun.baidu.com/\",\"content\":\"百度云旗下的 Git 代码托管平台\"},{\"nickname\":\"SourceForge\",\"site\":\"https://sourceforge.net/\",\"content\":\"又称 SF.net，是开源软件开发者进行开发管理的集中式场所\"},{\"nickname\":\"Bitbucket\",\"site\":\"https://bitbucket.org/\",\"content\":\"同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发\"},{\"nickname\":\"npm\",\"site\":\"https://www.npmjs.com/\",\"content\":\"JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。通过 npm 可以安装、共享、分发代码,管理项目依赖关系\"}],\".skill\":[{\"nickname\":\"LeetCode\",\"site\":\"https://leetcode-cn.com/\",\"content\":\"全球极客挚爱的技术成长平台\"},{\"nickname\":\"Topcoder\",\"site\":\"https://www.topcoder.com/\",\"content\":\"全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛\"},{\"nickname\":\"Codeforces\",\"site\":\"http://codeforces.com/\",\"content\":\"俄罗斯最大的算法比赛网站\"},{\"nickname\":\"Hihocoder\",\"site\":\"http://www.hihocoder.com/\",\"content\":\"技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务\"},{\"nickname\":\"LintCode\",\"site\":\"https://www.lintcode.com/\",\"content\":\"被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站\"},{\"nickname\":\"SPOJ\",\"site\":\"https://www.spoj.com/\",\"content\":\"波兰的算法刷题网站\"},{\"nickname\":\"NEUQ OJ\",\"site\":\"http://acmclub.cn/\",\"content\":\"一个在线的判题平台\"},{\"nickname\":\"洛谷\",\"site\":\"https://www.luogu.com.cn/\",\"content\":\"创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验\"},{\"nickname\":\"牛客网\",\"site\":\"https://www.nowcoder.com/contestRoom\",\"content\":\"中国最大的IT题库\"},{\"nickname\":\"计蒜客\",\"site\":\"https://nanti.jisuanke.com/oi\",\"content\":\"计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统\"},{\"nickname\":\"C语言网\",\"site\":\"https://www.dotcpp.com/oj/contest.html\",\"content\":\"在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！\"}],\".school\":[{\"nickname\":\"菜鸟教程\",\"site\":\"https://www.runoob.com/\",\"content\":\"提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识\"},{\"nickname\":\"W3school\",\"site\":\"https://www.w3school.com.cn/\",\"content\":\"领先的 Web 技术教程\"},{\"nickname\":\"前端网\",\"site\":\"http://www.qianduandaxue.com/\",\"content\":\"最好的自学web前端网站\"}],\".community\":[{\"nickname\":\"Stack Overflow\",\"site\":\"https://stackoverflow.com/\",\"content\":\"全球最受程序员欢迎的开发社区\"},{\"nickname\":\"CSDN\",\"site\":\"https://www.csdn.net/\",\"content\":\"全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台\"},{\"nickname\":\"博客园\",\"site\":\"https://www.cnblogs.com\",\"content\":\"代码改变世界\"},{\"nickname\":\"V2EX\",\"site\":\"https://www.v2ex.com/\",\"content\":\"V2EX = way to explore\"},{\"nickname\":\"掘金\",\"site\":\"https://juejin.im/\",\"content\":\"一个帮助开发者成长的社区\"},{\"nickname\":\"SegmentFault\",\"site\":\"https://segmentfault.com/\",\"content\":\"改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功\"},{\"nickname\":\"开源中国\",\"site\":\"https://www.oschina.net/\",\"content\":\"国内最大的开源技术社区\"},{\"nickname\":\"ITeye\",\"site\":\"https://www.iteye.com/\",\"content\":\"ITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践\"},{\"nickname\":\"51CTO\",\"site\":\"https://www.51cto.com/\",\"content\":\"技术成就梦想\"},{\"nickname\":\"ITPUB\",\"site\":\"http://www.itpub.net/\",\"content\":\"全球最大的学习分享平台\"},{\"nickname\":\"知乎\",\"site\":\"https://www.zhihu.com/\",\"content\":\"国内最受欢迎的知识性问答社区\"},{\"nickname\":\"简书\",\"site\":\"https://www.jianshu.com/\",\"content\":\"创作你的创作\"},{\"nickname\":\"云+社区\",\"site\":\"https://cloud.tencent.com/developer\",\"content\":\"来自腾讯的开发者技术分享社区\"},{\"nickname\":\"云栖社区\",\"site\":\"https://yq.aliyun.com/\",\"content\":\"阿里云面向开发者的开放型技术平台\"},{\"nickname\":\"极术社区\",\"site\":\"https://aijishu.com/\",\"content\":\"全球软硬件资源信息，只要你有问题，我们就能解答。\"}],\".serve\":[{\"nickname\":\"阿里云\",\"site\":\"https://www.aliyun.com/\",\"content\":\"为了无法计算的价值\"},{\"nickname\":\"腾讯云\",\"site\":\"https://cloud.tencent.com/\",\"content\":\"产业智变 云启未来\"},{\"nickname\":\"百度云\",\"site\":\"https://cloud.baidu.com/\",\"content\":\"计算无限可能\"},{\"nickname\":\"七牛云\",\"site\":\"https://www.qiniu.com/\",\"content\":\"国内领先的企业级云服务商\"},{\"nickname\":\"又拍云\",\"site\":\"https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral\",\"content\":\"专注 CDN、云存储、小程序开发方案、 短视频开发方案、DDoS高防等产品的国内知名企业级云服务商\"},{\"nickname\":\"Cloudflare\",\"site\":\"https://www.cloudflare.com/\",\"content\":\"网络性能和安全公司\"},{\"nickname\":\"jsDelivr\",\"site\":\"https://www.jsdelivr.com/\",\"content\":\"A free, fast, and reliable Open Source CDN for npm and GitHub\"}],\".sitetool\":[{\"nickname\":\"百度站长平台\",\"site\":\"https://ziyuan.baidu.com/\",\"content\":\"百度搜索资源平台 - 让网站更具价值\"},{\"nickname\":\"Google 站长平台\",\"site\":\"http://www.google.cn/webmasters/\",\"content\":\"支持、学习、互动交流和 Search Console – Google\"},{\"nickname\":\"Bing 网站管理员工具\",\"site\":\"https://www.bing.com/toolbox/webmaster/\",\"content\":\"Bing 网站管理员工具\"},{\"nickname\":\"站长工具 - 站长之家\",\"site\":\"http://tool.chinaz.com/\",\"content\":\"SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询\"},{\"nickname\":\"搜狗站长平台\",\"site\":\"http://zhanzhang.sogou.com/\",\"content\":\"全面掌握在搜狗搜索中的数据表现\"},{\"nickname\":\"360 站长平台\",\"site\":\"http://zhanzhang.so.com/\",\"content\":\"给网站带来更多流量和展现\"},{\"nickname\":\"超级 SEO 外链工具\",\"site\":\"https://tool.lusongsong.com/seo/\",\"content\":\"网站自动化宣传机器/免费的超级外链工具可批量增加外链\"},{\"nickname\":\"域名备案管理系统\",\"site\":\"http://www.beian.miit.gov.cn/\",\"content\":\"工业和信息化部ICP/IP地址/域名信息备案管理系统\"},{\"nickname\":\"公安备案网\",\"site\":\"http://beian.gov.cn/\",\"content\":\"全国互联网安全管理服务平台\"}],\".design\":[{\"nickname\":\"Iconfont\",\"site\":\"https://www.iconfont.cn/\",\"content\":\"阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能\"},{\"nickname\":\"Font Awesome\",\"site\":\"https://fa5.dashgame.com/#/%E5%9B%BE%E6%A0%87\",\"content\":\"一个基于CSS 和 LESS 的字体和图标工具包\"},{\"nickname\":\"Flaticon\",\"site\":\"https://www.flaticon.com/\",\"content\":\"海量扁平化免费的图标库\"},{\"nickname\":\"icons8\",\"site\":\"https://icons8.com/\",\"content\":\"独特系统平台风格和web图标库，下载免费图标，音乐\"},{\"nickname\":\"Unsplash\",\"site\":\"https://unsplash.com/\",\"content\":\"质量超高的免费图片素材库，无需注册，直接下载\"},{\"nickname\":\"Mixkit\",\"site\":\"https://mixkit.co/\",\"content\":\"免费、高质量、可商用的视频素材分享网站\"},{\"nickname\":\"WebGradients\",\"site\":\"https://webgradients.com/\",\"content\":\"渐变色搭配方案\"},{\"nickname\":\"CoolHue2.0\",\"site\":\"https://webkul.github.io/coolhue/\",\"content\":\"渐变色搭配方案\"},{\"nickname\":\"Gradient\",\"site\":\"https://gradient.shapefactory.co/?a=540A43&b=629EA1&d=25\",\"content\":\"渐变色搭配方案\"},{\"nickname\":\"UiGradients\",\"site\":\"https://uigradients.com/#JShine\",\"content\":\"渐变色搭配方案\"}],\".tools\":[{\"nickname\":\"智图\",\"site\":\"https://zhitu.isux.us/\",\"content\":\"腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台\"},{\"nickname\":\"程序员的工具箱\",\"site\":\"https://tool.lu/\",\"content\":\"站长工具、代码格式化、压缩、加密、解密、下载链接转换等\"},{\"nickname\":\"OSCHINA.NET社区\",\"site\":\"https://tool.oschina.net/\",\"content\":\"常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等\"},{\"nickname\":\"记磊工具箱\",\"site\":\"https://tools.ly522.com/\",\"content\":\"Dns检测、CSS格式化、超级Ping、端口扫描等\"},{\"nickname\":\"孟坤工具箱\",\"site\":\"http://tool.mkblog.cn/\",\"content\":\"css一键美化、文本差异比较、代码高亮等\"},{\"nickname\":\"Text to ASCII\",\"site\":\"http://patorjk.com/software/taag/\",\"content\":\"Text to ASCII Art Generator，字符串转成 ASCII 码图案\"},{\"nickname\":\"临时邮箱\",\"site\":\"https://linshiyouxiang.net/\",\"content\":\"匿名注册不常用的网站/论坛，保护隐私免骚扰\"},{\"nickname\":\"TinyPNG\",\"site\":\"https://tinypng.com/\",\"content\":\"PNG/JPG图片在线压缩利器\"},{\"nickname\":\"图片格式在线转换\",\"site\":\"https://ezgif.com/png-to-webp\",\"content\":\"webp图片格式在线转换\"},{\"nickname\":\"SVGOMG\",\"site\":\"https://jakearchibald.github.io/svgomg/\",\"content\":\"SVG在线压缩平台\"},{\"nickname\":\"Loading\",\"site\":\"https://loading.io/\",\"content\":\"制作GIF、SVG、CSS加载动画图标\"},{\"nickname\":\"Preloaders\",\"site\":\"https://www.logaster.cn/\",\"content\":\"Loading 懒加载动画在线制作\"},{\"nickname\":\"移除图片背景\",\"site\":\"https://www.remove.bg/\",\"content\":\"一键智能抠图\"},{\"nickname\":\"KMS服务\",\"site\":\"https://kms.avg.cx/\",\"content\":\"KMS激活Windows一键脚本\"}]}"},{"title":"我的收藏","date":"2025-05-17T05:51:06.629Z","updated":"2025-05-17T05:51:06.629Z","comments":false,"path":"stars/index.html","permalink":"https://binwenwu.github.io/stars/index.html","excerpt":"","text":".links-content { margin-top:1rem; } .link-navigation::after { content:\" \"; display:block; clear:both } .card { position:relative; width:25%; padding:0; border-radius:10px; transition-duration:.3s; margin-bottom:1rem; margin-left:16px; display:block; float:left; box-shadow:0 2px 6px 0 rgba(0,0,0,.12); background: transparent; overflow:hidden; } .card:hover:before, .card:focus:before, .card:active:before { -webkit-transform: scale(1); transform: scale(1); } .card:before { content: \"\"; position: absolute; z-index: -1; top: 0; left: 0; right: 0; bottom: 0; background-image: linear-gradient(to right, #fdcbf1 0%, #fdcbf1 1%, #e6dee9 100%); -webkit-transform: scale(0); transform: scale(0); -webkit-transition-property: transform; transition-property: transform; -webkit-transition-duration: 0.15s; transition-duration: all 0.15s; -webkit-transition-timing-function: ease-out; transition-timing-function: ease-out; } .card:hover,.card:hover > .card-header a,.card:hover > .card-content a{ transform:scale(1); } @media(max-width:567px) { .card{ margin-left:16px; width:calc((100% - 16px)/2) } .card:nth-child(2n+1) { margin-left:0 } .card:not(:nth-child(2n+1)) { margin-left:16px } } @media(min-width:567px) { .card { margin-left:16px; width:calc((100% - 32px)/3) } .card:nth-child(3n+1) { margin-left:0 } .card:not(:nth-child(3n+1)) { margin-left:16px } } @media(min-width:768px) { .card { margin-left:16px; width:calc((100% - 48px)/4) } .card:nth-child(4n+1) { margin-left:0 } .card:not(:nth-child(4n+1)) { margin-left:16px } } .posts-expand .post-body img { margin:0; padding:0; border:0 } .card .card-header { display:block; text-align:center; padding:.25rem .25rem; font-weight:500; color:#222222; white-space:nowrap; } .card .card-header a { font-style:normal; color:#222222; font-weight:700; text-decoration:none; border:0; overflow:hidden } .card .card-header a:hover { color:#222222; text-decoration:none; border:0 } .card .card-content { display:block; text-align:center; padding: 0 .25rem .25rem .25rem; font-weight:500; font-size: smaller; color:#222222; white-space:nowrap; } .card .card-content div { overflow:hidden } .card .card-content a { font-style:normal; color:#222222; font-weight:500; text-decoration:none; border:0; overflow:hidden } 我的常用 官方文档 代码托管 技能训练 学习平台 开发者社区 云服务 站长工具 设计素材 实用工具"},{"title":"","date":"2025-05-17T05:51:06.629Z","updated":"2025-05-17T05:51:06.629Z","comments":true,"path":"stars/stars.js","permalink":"https://binwenwu.github.io/stars/stars.js","excerpt":"","text":"// 采用一个多对象JSON文件存储所有数据的方式 stars = { init: function (url) { var that = this; $.getJSON(url, function (data) { for (var className in data) { var classData = data[className] that.render(classData, className) } } ); }, render: function (data, name) { var nickname, site, li = \"\"; for (var i = 0; i < data.length; i++) { nickname = data[i].nickname; site = data[i].site; content = data[i].content; li += '' + '' + '' + nickname + '' + '' + '' + '' + content + '' + '' + ''; } $(name).append(li); } } // 传入json文件的路径 stars.init(\"./allStars.json\")"},{"title":"订阅","date":"2023-07-28T05:01:46.000Z","updated":"2025-05-17T09:11:27.786Z","comments":false,"path":"subscribe/index.html","permalink":"https://binwenwu.github.io/subscribe/index.html","excerpt":"","text":"订阅本站 首先，对每一位来到这里的TANKENQI的朋友们说声 “有幸遇见，很高兴认识你” 👋 创立 TANKENQI 的初衷是想能够有一个让自己积累知识、积累兴趣的地方；是属于自己的温暖小窝；也是偌大的社会里的属于自己的内心避风港 和他人分享，会让这些成为积累和沉淀。如果能够帮助到更多的人，帮助更多人解决问题，那一定是非常棒的事情 与大多数垂直类的技术博客不同，这里的种类会非常的繁杂，有技能的教程干货、有生活上的吐槽和想法；所以一般我研究什么、发现了什么都会分享在这里 这些就是创造 TANKENQI 的本意，也是我分享生活的方式。有幸能和你相遇在这里，相信我们能共同留下一段美好记忆 邮件通知 邮件通知采用follow的rss更新采集通知功能，能在本博客更新后发一封邮件通知到您。当然了，这需要你留下你的邮件地址 点击上方邮件订阅，填入你的邮件地址订阅即可 RSS订阅 你可以使用第三方RSS客户端接收到博客的文章摘要通知 https://binwenwu.github.io/atom.xml"},{"title":"番茄时钟","date":"2025-05-17T05:51:06.629Z","updated":"2025-05-17T05:51:06.629Z","comments":false,"path":"tomato_clock/index.html","permalink":"https://binwenwu.github.io/tomato_clock/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-03T12:51:29.000Z","updated":"2025-05-17T05:51:06.629Z","comments":true,"path":"tags/index.html","permalink":"https://binwenwu.github.io/tags/index.html","excerpt":"","text":""},{"title":"网站更新日志","date":"2023-10-01T11:56:00.000Z","updated":"2025-05-17T05:51:06.630Z","comments":true,"path":"update/index.html","permalink":"https://binwenwu.github.io/update/index.html","excerpt":"","text":"CrypTek v1.0.0 2023-10-01 经过了深思熟虑，博客主题独立啦！ 现在的主题叫做CrypTek，具体见： 引用站外地址 博客正式独立主题啦！ Tankenqiの小窝 目前博客有： 更好的右键菜单 留言弹幕 博客设置（功能贼多大家自己看） 不错的UI，至今为止主css(style.css)有3k行 一些小功能比如公祭日弹窗自动欢迎等 大概就是这些了。 Acryple v1.0.110 2022-12-13 加入pwa 全站采用存储桶加速，可惜并没有卵用 很多资源转为了白嫖eleme 抛弃metingjs，目前aplayer的歌曲托管在eleme npm镜像中 友链添加随机头像 博客设置画饼的三个功能仍未修复 qwq 修复一些bug 大改swiper，参考自Leonus 完成Build101的大部分饼 修复了朋友圈爬取bug sw换回cyfan 套上了灵天盾亚太CDN 因为性能问题，移除了文章日历 给导航栏加上滚动动画（画饼） bb布局重构（画饼） 分类标签栏bug修复（画饼） 语雀云端写作（因bug已回滚） gulp（因bug已回滚） 文章进度显示（画饼） 修复pjax的bug 右键菜单功能完善 Acryple v1.0.101 2022-12-06 （PS：部分画大饼 壮举：适配pjax！！！ 修复黑幕的bug 修复评论弹幕dom错误，溢出的bug 弹幕换用swiper方案，并且优化样式 首页bb增加天数显示，以及换用swiper(预计) 修复一些bug（e.g.aplayer、博客设置 优化部分动画/样式 完善博客控制面板，仍有部分未完工 修复部分文章页面溢出的bug 悼念某人，banner换图 pace换用xlenco的胶囊方案 由于未知特性删除了pjax的加载动画，首次保留 部分资源换用缤纷云 换用空梦的sw 不断优化加载速度ing… 修复首页轮播bug(预计) 评论样式修改，预计添加用户tag功能 更换背景没有时效限制了 欢迎文本 左右栏切换 弹幕开关设置自动显隐 落樱特效 aplayer显隐功能 明暗模式自动切换、固定导航栏功能（预计） 边栏样式修改 修复点赞第一赞没反应的bug 修复ghactions部署没有npm缓存的bugtnnd我等十几分钟安装依赖等几个月了，结果是顺序反了 目前朋友圈后端出现了bug，导致不更新，请静待修复 Acryple v1.0.100 2022-12-04 修复部分bug（不，特性 优化部分动画/样式 修改右键菜单 重写博客设置，并将 rightside 的部分功能移动到博客设置中，灵感来源于ichika（未完工 支持隐藏 ASide 了 短暂变灰 修复公祭日js的bug 修复右键菜单在主页也能开启阅读模式的bug 优化手机端阅读体验，去卡片化 优化latex样式 修复部分分辨率下无导航栏的bug aplayer的体验更好了 优化部分样式，适配部分还未适配的黑暗模式 加了一个字体 重写分类和标签、归档页的样式，来源于ichika 优化页脚查看体验 优化网站性能 支持全屏 css 5k+ qpzc 解封辣！！！ 究极跳号？！CRT18:?! Acryple v1.0.92 修复部分bug（不，特性 优化部分样式 更改了博客设置的部分主题色 pages页面在Acrylic主题下的背景得到了改善 更改加载页面背景 重新进行部分断点 把博客api\\服务全部迁移到了另一个github账号~~(垃圾桶)~~上 优化搜索UI 对butterfly4.5.1进行了选择性同步(优化繁体字库) 疫情退退退awa Acryple v1.0.91 修复部分bug（不，特性 为APlayer进行完善 添加早报、木鱼、空调页面，参考Chuckle 更改关于页面，参考安知鱼的教程 尝试npm全站静态化，最终失败放弃qwq 优化sw，加载速度略有提升 新增文章统计 优化部分样式 Acryple v1.0.81 2022-11-23 修复部分bug（不，特性 优化性能问题，对弹幕进行了节流 添加APlayer，可惜没有pjax qwq 优化弹幕（更洪化了） 调整网站布局 修改一些样式 PS：在1.0.51偷偷加了一号字号你们发现没有(doge) Acryple v1.0.51 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 换用Twikoo-magic表情包 为了OI添加 KaTeX\\textbf{ \\KaTeX} KATE​X 修复跳转链接因原有bug被迫使原页面刷新的bug Acryple v1.0.14 2022-11-10 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 增加浏览器过期提醒以及banIE，参考chuckle以及b站 增加fps显示 评论表情添加颜文字 修复手机端侧边栏bug PS：作为一个萌新OIer依然没有考虑发oi文 ╮(╯▽╰)╭ 以前的更新日志哔哩哔哩 (゜-゜)つロ 干杯！ 2022 07-02 终于弄好网站了，庆祝一下🎉 Gitalk不知道为什么不显示出来… 07-03 小更新，修改细节 作者的Html实在太菜了，效果并不好 07-04 大更新 修改了很多ui 07-05 大更新 修改细节UI和友链部分，增加吐槽部分 07-06 小更新，做好一些功能并且写了第一篇文章 07-08 大更新，更改首页布局，增加首页分区 07-09 小更新，修改细节，适配手机端，修复bug，说说由Artitalk换为BBtalk 07-14 前面几天忘记写更新了，更新了很多UI和功能。。。 07-18 前面几天又忘记写更新了小小修改了一些布局，把鸽了很久的博客写完了并且还加了萌百的黑幕，没有你知道的太多了差评 07-22 前面几天又双忘记写更新了折腾了很多，加了自己的域名，把你知道的太多了弄出来了，并且修复了很多js的bug，把unpkg换成fastly.jsdelivr或者elemecdn，提升速度（竟然有人加了我友链，怎么知道这个网站的？） 08-12 前面几天又双叒忘记写更新了还是折腾了很多，按照冰糖红茶大佬们的方法加了不少东西，比如那个人潮汹涌模拟器（主页的）、文章点赞、无缝跳转等等，换成jsdelivr加速，同时也在最大化利用GoormIDE，不过在险些没有数据之后就尽可能迁移到了其它没有风险的平台。 08-25 最近在糖果屋群友们的建议和帮助下修改了很多功能,以后每隔一段时间都会写详细的日志而不是像前面简单概括了。 留言板的弹幕是真的像b站视频弹幕了，过一段时间修复了bug之后放教程 新增博客设置，做了一个极简风的主题，支持更换主题色，也可以换回之前的主题，可以禁用模糊效果和开启硬件加速提升性能 修复了部分排版bug，对safari进行了一些适应，感谢Apple Store和洪哥的帮助。 增加了hover的缩放效果，有层次感 优化动画 修复留言弹幕、右键菜单的bug并且把新版的代码更新到文章中 优化细节样式 新增最新文章标记 总算部署好朋友圈了！leancloud国内版垃圾！"},{"title":"工具","date":"2022-07-13T07:23:02.000Z","updated":"2025-05-17T05:51:06.629Z","comments":true,"path":"tools/index.html","permalink":"https://binwenwu.github.io/tools/index.html","excerpt":"","text":"镜像站常用的PyPi/npm/SDK镜像站 TUNA 清华大学开源镜像站 豆瓣PYPI源 豆瓣PYPI镜像站 jsDelivr jsDelivr静态资源加速（GFW已墙） unpkg 另一个静态资源加速CDN（没墙） 资源下载类好用的资源下载/收录站 MSDN,我告诉你 微软MSDNED2K镜像收录站 唧唧Down 下载B站视频 无损生活 免费下载全网绝大部分无损音乐 百度网盘简易下载助手 特别好用的bd网盘破解器（不知道为什么公众号分享很怕敏感词） 日常工具常用日常工具 计时器 闹钟网计时器 图片系列关于图片的工具 Bigjpg 高清修复图片与降噪 waifu2x 高清修复图片与降噪，性能貌似好一点 jpgrm 高清修复图片与降噪 Sheilds 制作Github项目徽章 极简壁纸 海量高清壁纸美图&二次元图片 常用测试网站测试一些基础功能 还没做完呢 你瞅啥？还妹做完呢！"},{"title":"早报","date":"2022-11-24T23:37:35.000Z","updated":"2025-05-17T05:51:06.630Z","comments":true,"path":"zaobao/index.html","permalink":"https://binwenwu.github.io/zaobao/index.html","excerpt":"","text":""}],"posts":[{"title":"CentOS中为Docker配置代理","slug":"CentOS中为Docker配置代理","date":"2024-04-10T13:46:58.000Z","updated":"2025-05-17T05:51:06.587Z","comments":true,"path":"posts/8bacdc7a/","link":"","permalink":"https://binwenwu.github.io/posts/8bacdc7a/","excerpt":"","text":"背景 因为一些安全原因，公司的机器网络环境不能直接访问外网，需要配置代理才能够访问，导致我使用拉取镜像的时候连接不到，报了如下的错误 Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled while...... 一般来说主机通过代理访问外网方式就是通过在命令行设置 export 来设置代理，如下所示: export http_proxy=http://proxy_server:7890 export https_proxy=https://proxy_server:7890 但是docker拉取镜像是通过 docker daemon 服务完成，docker daemon 服务是在另一个进程中，不会读取当前shell 命令行的代理，所以 docker pull 会失败，官网的说明如下: 代理配置 创建目录 12mkdir /etc/systemd/system/docker.service.dcd /etc/systemd/system/docker.service.d 创建配置文件http-proxy.conf，内容如下： 我这里的代理没有对外提供https，因此所以我在https_proxy协议还是写了http的 1234[Service]Environment=&quot;HTTP_PROXY=http://your.proxy.server:port/&quot;Environment=&quot;HTTPS_PROXY=http://your.proxy.server:port/&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.1&quot; 重新加载systemd守护程序 1systemctl daemon-reload 重启Docker 1systemctl restart docker 验证是否已经加载 1systemctl show docker --property Environment Environment= … 配置完后使用docker pull，发现有反应了","categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"CentOS","slug":"CentOS","permalink":"https://binwenwu.github.io/tags/CentOS/"}]},{"title":"3DCityDB 性能测试","slug":"3DCityDB 性能测试","date":"2024-04-07T07:56:08.000Z","updated":"2025-05-17T05:51:06.586Z","comments":true,"path":"posts/8066b642/","link":"","permalink":"https://binwenwu.github.io/posts/8066b642/","excerpt":"","text":"1 硬件环境 芯片：Apple M2 Pro 内存：32GB 核数：12 2 测试流程 2.1创建3DCityDB数据库 方便起见使用Docker 拉取镜像 1docker pull 3dcitydb/3dcitydb-pg 运行容器 1234docker run -d -p 5432:5432 --name cdb \\ -e POSTGRES_PASSWORD=123456 \\ -e SRID=25832 \\3dcitydb/3dcitydb-pg 2.2 下载Importer/Exporter 下载链接：https://github.com/3dcitydb/importer-exporter/releases 使用Docker形式也行，具体参见文档-1.5.2节： 下载完毕后根据系统进行启动 3DCityDB-Importer-Exporter.bat (Microsoft Windows family) 3DCityDB-Importer-Exporter (UNIX/Linux/Mac OS family) 在大多数平台上，双击启动脚本或其快捷方式即可运行，但对于某些 UNIX/Linux 发行版，必须在 shell 环境中运行启动脚本 12chmod u+x 3DCityDB-Importer-Exporter./3DCityDB-Importer-Exporter 2.3 设置数据库连接 2.4 开始测试 2.4.1 导入测试 测试数据集来自增强的纽约市 3D 建筑模型 导入模式：Import All 测试结果 Data Size Number of buildings Import time（Avg） DA1_3D_Buildings_Merged.gml.zip 412.3 MB 19,408 01min,44s DA5_3D_Buildings_Merged.gml.zip 747.3 MB 34,082 03min,16s DA8_3D_Buildings_Merged.gml.zip 1.20 GB 66,277 06min,21s DA19_3D_Buildings_Merged.gml.zip 2.24 GB 105,569 12min,50s 2.4.2 查询测试 本实验测试从不同体积量的数据库中检索出不同复杂程度的模型所需时长 测试所用具有不同体积量的数据库 ID Size Number of buildings 子节点数量 DB1 500 MB 37,149 21,24255 DB2 4587 MB 277,5159 246,98085 不同复杂程度三维场景在不同体积数据库下的检索效率 场景 ID 子节点数量 Number of buildings DB1 Time DB2 Time S1 10098 918 0.391 s 1.44 s S2 22869 2110 0.520 s 1.502 s S3 33506 3046 0.664 s 1.732 s S4 45859 4169 0.783 s 1.901 s S5 82478 7498 1.254 s 2.316 s","categories":[{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/categories/GIS/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/tags/GIS/"},{"name":"3DCityDB","slug":"3DCityDB","permalink":"https://binwenwu.github.io/tags/3DCityDB/"}]},{"title":"CentOS安装GDAL","slug":"CentOS安装GDAL","date":"2024-02-09T07:26:08.000Z","updated":"2025-05-17T05:51:06.587Z","comments":true,"path":"posts/84542e25/","link":"","permalink":"https://binwenwu.github.io/posts/84542e25/","excerpt":"","text":"1 GDAL ≥ 3.5 安装 安装CMake 12345678# 下载wget -c -P /storage/software/gdal-related-libs https://github.com/Kitware/CMake/releases/download/v3.13.2/cmake-3.13.2.tar.gz# 解压tar -zxvf cmake-3.13.2.tar.gz# 安装./bootstrapmakemake install 安装sqlite（官网：https://www.sqlite.org/download.html） 123456789# 下载wget -c -P /gdal https://www.sqlite.org/2023/sqlite-autoconf-3440000.tar.gz# 解压tar -xvzf sqlite-autoconf-3440000.tar.gz# 安装./configuremakemake installldconfig 安装proj（官网：https://proj.org/download.html） 123456789# 下载wget -c -P /gdal https://download.osgeo.org/proj/proj-8.1.0.tar.gz# 解压tar -xvzf proj-8.1.0.tar.gz# 安装./configuremakemake checkmake install 安装GDAL（教程：https://gdal.org/development/building_from_source.html） 123456789101112# 下载wget -c -P /gdal http://download.osgeo.org/gdal/3.8.0/gdal-3.8.0.tar.gz# 解压tar -xvzf gdal-3.8.0.tar.gz# 编译安装cd /gdal/gdal-3.8.0# 创建安装路径mkdir buildcd buildcmake ..cmake --build .cmake --build . --target install 编写环境变量 1234567# 在export PATH下一行添加，依赖的动态库和静态库添加到LD_LIBRARY_PATH环境变量中去export PATH=$PATH:/usr/local/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib# 使环境变量生效source ~/.bashrc# 查看GDAL版本信息gdalinfo --version 2 GDAL ＜ 3.5 安装 安装sqlite和proj（略） 安装gcc gcc-c++ 1yum -y install gcc gcc-c++ kernel-devel 安装GDAL 12345tar -zxvf gdal-3.0.4.tar.gzcd gdal-3.0.4./configuremakemake install 编写环境变量 1234567# 在export PATH下一行添加，依赖的动态库和静态库添加到LD_LIBRARY_PATH环境变量中去export PATH=$PATH:/usr/local/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib# 使环境变量生效source ~/.bashrc# 查看GDAL版本信息gdalinfo --version 3 yum 安装 GDAL 添加EPEL仓库 1sudo yum install epel-release 安装GDAL及其相关软件包 1sudo yum install gdal gdal-devel gdal-python 查看版本 1gdalinfo --version","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://binwenwu.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"gdal","slug":"gdal","permalink":"https://binwenwu.github.io/tags/gdal/"}]},{"title":"Bigtable —— 简介","slug":"Bigtable —— 简介","date":"2024-01-12T07:06:08.000Z","updated":"2025-05-17T05:51:06.587Z","comments":true,"path":"posts/4b68374a/","link":"","permalink":"https://binwenwu.github.io/posts/4b68374a/","excerpt":"","text":"1 Bigtable概览 ​ Cloud Bigtable 是稀疏填充的表，可以扩展到数十亿行和数千列，可让您存储 TB 级甚至是 PB 级的数据。每行中都会有一个被编入索引的值；这个值称为行键。Bigtable 非常适合以低延迟存储大量单键数据。它支持以低延迟方式实现高读写吞吐量，是 MapReduce 操作的理想数据源。 ​ Bigtable 通过多个客户端库公开给应用，包括适用于 Java 的 Apache HBase 库的受支持扩展程序。因此，它可与开源大数据软件的现有 Apache 生态系统集成在一起。 ​ 与自行管理的 HBase 安装相比，Bigtable 强大的后端服务器具有多项关键优势： 超高扩缩能力。Bigtable 的扩缩能力与您集群中的机器数量成正比。自行管理的 HBase 安装存在一个设计瓶颈，在达到特定阈值后会对性能造成限制。Bigtable 不存在此瓶颈，因此您可以对集群进行纵向扩容以处理更多读写操作。 易于管理。Bigtable 可以透明方式处理升级和重启，而且会自动保持高度的数据耐用性。如需复制数据，只需为您的实例添加第二个集群，系统就会自动开始复制。您无需管理副本或区域；只需设计表架构，Bigtable 即可为您处理其余事务。 无需停机即可调整集群大小。您可以扩大 Bigtable 集群，运行几个小时以处理某个大型负载，然后再缩减集群，整个过程中无需停机。更改集群的大小后，在负载状态下，Bigtable 通常只需几分钟即可平衡集群中所有节点的性能。 2 适合的场景 ​ Bigtable 非常适合需要高吞吐量和可伸缩性键值对数据的应用，其中每个值通常不超过 10 MB。Bigtable 也擅长用作批量 MapReduce 操作、流处理/分析和机器学习应用的存储引擎。 ​ 您可以使用 Bigtable 来存储和查询以下所有类型的数据： 时间序列数据，例如多个服务器在一段时间内的 CPU 和内存使用率。 营销数据，例如购买记录和客户偏好设置。 金融数据，例如交易记录、股票价格和货币汇率。 物联网数据，例如来自电表和家用电器的用量报告。 图表数据，例如有关用户相互间连接方式的信息。 3 Bigtable存储模型 ​ Bigtable 将数据存储在扩缩能力极强的表中，其中每个表都是有序的键值对映射。该表由行（通常每行描述一个实体）和列（包含每行的各个值）组成。每一行都通过一个行键编入索引，而彼此相关的列通常会被划分到一个列族中。每一列由列族和列限定符（即列族中的唯一名称）的组合来标识。 ​ 每个行/列交集可以包含多个单元格。每个单元格包含相应行和列的带时间戳的唯一版本数据。在列中存储多个单元格可提供相应行和列的已存储数据如何随时间的推移而变化的记录。Bigtable 表属于稀疏表；如果特定行中未使用某列，则该列就不会占用任何空间。 此图中有几点需要注意： 行中可以不使用列 给定行和列中的每个单元都有一个唯一的时间戳 (t) 4 Bigtable架构 下面显示了Bigtable整体架构的简化版本： 如图所示，所有客户端请求都是先经过前端服务器，然后再发送到 Bigtable 节点。（在原始 Bigtable 白皮书中，这些节点被称为“片服务器”。）节点以 Bigtable 集群的形式组织，而后者属于 Bigtable 实例（集群的容器）。 ☆ 注意：该图显示的是单集群实例。您还可以添加集群来复制数据，从而提高数据可用性和耐用性。 集群中的每个节点会处理对该集群的一部分请求。通过向集群添加节点，不但可以增加集群能够同时处理的并发请求数量，添加节点还会提高集群的最大吞吐量。如果您通过添加其他集群启用复制功能，还可以将不同类型的流量发送到不同的集群。然后，如果一个集群不再可用，您可以故障切换到另一个集群。 Bigtable 表被分成多个连续的行块（称为片），旨在帮助平衡查询工作负载。（片类似于 HBase 区域。）片以 SSTable 格式存储在 Google 的文件系统 Colossus 上。SSTable 提供了一种持久、有序且不可变的键值对映射，其中键和值都可以是任意的字节字符串。每个片都与特定的 Bigtable 节点相关联。除了 SSTable 文件之外，所有写入内容都会在获得 Bigtable 确认后立即存储在 Colossus 的共享日志中，从而提高了持久性。 重要的是，数据永远不会存储到 Bigtable 节点本身；每个节点都有指向 Colossus 中所存储的一组片的指针。因此： 您可以很快将片从一个节点重新平衡到另一个节点，因为实际数据不会被复制。Bigtable 只会更新每个节点的指针。 您可以快速从 Bigtable 节点故障进行恢复，因为只有元数据必须迁移到替换节点。 当 Bigtable 节点发生故障时，任何数据都不会丢失。 如需详细了解如何使用这些基本组件，请参阅实例、集群和节点。 5 负载平衡 ​ 每个 Bigtable 区域都是由一个主实例进程管理，该进程可使集群内的工作负载和数据量达到平衡。此进程会将较繁忙/较大的片拆分成两半，而将较少访问/较小的片合并在一起，并根据需要在各节点之间重新分配这些片。如果某个片遇到流量高峰，Bigtable 会先将该片拆分成两部分，然后再将其中一个新片移至另一个节点。Bigtable 可自动管理拆分、合并和再平衡操作，从而节省了手动管理片的工作量。了解性能部分详细介绍了此过程。 ​ 为了使 Bigtable 达到最佳写入性能，请尽可能均匀地在各节点间分配写入操作，这一点非常重要。实现这一目标的一种方法是按不可预测的顺序使用行键。例如，用户名在整个字母表中的分布往往是大致均匀的，因此将用户名包含在行键的开头位置通常会使写入操作得到均匀分布。 ​ 同时，对相关行进行分组以使它们彼此相邻也很有用，这可让您更高效地同时读取多个行。例如，如果您要存储一段时间内不同类型的天气数据，您可以在行键中依次添加收集了这些数据的位置和时间戳（例如 WashingtonDC#201803061617）。这种类型的行键会将来自一个位置的所有数据组织成连续范围的行。对于其他位置，所属的行将以不同的标识符开头；如果有多个位置都在以相同速率收集数据，那么写入操作仍然会均匀分布到各片之中。 ​ 如需详细了解如何为您的数据选择合适的行键，请参阅选择行键。 6 受支持的数据类型 ​ 在大多数情况下，Bigtable 会将所有数据视为原始字节字符串。Bigtable 只有在执行增量操作时才会尝试确定类型，在这种情况下，目标必须是编码为 8 字节 big-endian 值的 64 位整数。 7 内存和磁盘使用率 以下部分介绍了几种 Bigtable 组件对实例的内存和磁盘使用率的影响。 未使用的列 ​ 未在 Bigtable 行中使用的列不会占用该行中的任何空间。每一行实质上都是键/值对条目的集合，其中键由列族、列限定符和时间戳组成。如果某行不包含特定列的值，则说明键/值对条目不存在。 列限定符 ​ 列限定符会占用行的空间，因为行中使用的每个列限定符会存储在该行中。因此，将列限定符用作数据通常是有效的做法。 压缩 ​ Bigtable 会定期重写您的表以移除已删除的条目，并重新整理数据以提高读写操作的效率。我们将这一过程称为压缩。对于压缩，没有相关的配置设置，因为 Bigtable 会自动压缩您的数据。 变更和删除 ​ 行更改会占用额外的存储空间，因为 Bigtable 按顺序存储更改且仅定期进行压缩。对表进行压缩时，Bigtable 会移除不再需要的值。如果您更新某单元格中的值，则原始值和新值都会在磁盘上存储一段时间，直到数据得到压缩为止。 ​ 删除也会占用额外的存储空间（至少短期内是这样），因为删除实际上是一种特殊类型的更改。在表得到压缩之前，删除将占用额外的存储空间而不会释放空间。 数据压缩 ​ Bigtable 采用智能算法自动压缩您的数据。您无法为表配置压缩设置。但是，了解如何存储数据以便高效地进行压缩是很有用的： 随机数据不能像图案化数据那样有效地压缩。 规律性数据包括文本，例如您正在阅读的页面。 当相同值彼此靠近时，压缩效果最佳（无论这些值是位于相同行还是相邻行）。如果您排列行键以使包含相同数据块的行彼此相邻，则可以高效地压缩数据。 Bigtable 会压缩大小不超过 1 MiB 的值。 如果您存储的值大于 1 MiB，请先对其进行压缩，然后再将其写入 Bigtable，以节省 CPU 周期、服务器内存和网络带宽。 8 数据耐用性 ​ 当您使用 Bigtable 时，您的数据将使用 Google 数据中心的存储设备存储在 Colossus 上，这是 Google 提供的一个极为耐用的内部文件系统。您无需运行 HDFS 集群或任何其他文件系统即可使用 Bigtable。在后台，Google 利用专有的存储方法来实现数据耐用性，并高于标准 HDFS 三向复制功能所提供的耐用性。 ​ 使用复制功能时，耐用性会进一步提高。Bigtable 会在您选择的位置为复制实例的每个集群保留一份单独的数据副本。 9 一致性模型 ​ 单集群 Bigtable 实例可提供强一致性。默认情况下，具有多个集群的实例提供最终一致性，但对于某些用例，这些实例可以配置为提供读己所写一致性或强一致性，具体取决于工作负载和应用配置文件设置。 10 安全性 ​ 对 Bigtable 表的访问权限通过您的 Google Cloud 项目以及您分配给用户的 Identity and Access Management (IAM) 角色控制。例如，您可以分配 IAM 角色，针对性地防止特定用户读取表、对表执行写入操作或创建新实例。如果某人无权访问您的项目，或者没有适当 Bigtable 权限的 IAM 角色，则无法访问您的任何表。 ​ 您可以管理项目级层、实例级层和表级层的安全性。 Bigtable 不支持行级、列级或单元级的安全限制。 11 加密 ​ 默认情况下，存储在 Google Cloud 中的所有数据（包括 Bigtable 表中的数据）都会使用我们用于自己的加密数据的同一强化密钥管理系统进行静态加密。 ​ 如果您希望更好地控制用于加密 Bigtable 静态数据的密钥，可以使用客户管理的加密密钥 (CMEK)。 12 备份 ​ 借助 Bigtable 备份，您可以保存表架构和数据的副本，并可在以后通过该副本将内容恢复到一个新表中。使用备份及备份副本，无论源表位于何处，您都可以在包含 Bigtable 实例的任何区域或项目中将内容恢复到一个新表中。 13 变更数据捕获 ​ Bigtable 以变更数据流的形式提供变更数据捕获 (CDC)。借助变更数据流，您可以在数据变更发生时捕获数据更改并将其流式传输到表中。您可以使用 Dataflow 等服务读取变更数据流，以支持数据分析、审核、归档要求和触发下游应用逻辑等使用场景。如需了解详情，请参阅变更数据流概览。 14 使用应用配置文件来请求路由 通过应用配置文件路由政策，您可以控制哪些集群将处理从应用传入的请求。路由政策包括如下选项： 单集群路由：将所有请求发送到单个集群。 多集群路由到任何集群：将请求发送到实例中最近的可用集群。 集群组路由：将请求发送到实例中选定集群组内最近的可用集群。","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://binwenwu.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Bigtable","slug":"Bigtable","permalink":"https://binwenwu.github.io/tags/Bigtable/"}]},{"title":"Apache Hbase —— 简介","slug":"Hbase的数据存储结构","date":"2024-01-11T08:23:08.000Z","updated":"2025-05-17T05:51:06.588Z","comments":true,"path":"posts/ec7eb22a/","link":"","permalink":"https://binwenwu.github.io/posts/ec7eb22a/","excerpt":"","text":"1 简介 HBase 是以 Google 的 Bigtable 为模型的开源非关系型分布式数据库，提供了一种存储大量稀疏数据的容错方式，适用于需要低延迟随机访问和高达 PB 级的海量存储的用例。 HBase采用共享存储架构，将计算层与存储层分开，存储层通常位于HDFS（Hadoop分布式文件系统）上。这种架构选择实现了吸引人的功能，如平滑扩展和成本优化等。以下是一些用例，在这些用例中，HBase 可能是一个不错的候选者。 近乎实时的大规模分布式键值或表模式存储系统，数据量从 100 TerraBytes 到 100s PetaBytes 甚至更高 高吞吐量、写入密集型应用程序，可以容忍延迟波动，大约 100 毫秒 按行键顺序扫描是必需的读取模式 与Hadoop生态系统结合使用，如MapReduce、Spark、Flink、Hive、HDFS等 结构化、半结构化数据架构，可选择稀疏分布 一些具体用例包括： 电子商务订购系统。每日订单和用户操作可以存储在 HBase 中，实现对海量订单的低延迟随机访问。历史订单数据也可以存储在HBase中，通过MapReduce、Spark、Flink等计算框架运行离线分析作业 搜索引擎。网络链接的原始内容以及分析特征数据可以存储在 HBase 中，以计算搜索结果排名等 日志聚合和指标。例如，OpenTSDB（开放时序数据库）是一个专门用于日志聚合和指标收集的开源数据库系统 下面列出了 HBase 的一些功能： 批量加载。数据迁移等用例可能需要将大量数据导入 HBase。读出每一行数据，然后写入 HBase 效率低下，有时甚至不可行。HBase 提供批量负载，支持直接访问 HDFS 的数据，绕过 HBase 的大部分写入路径以提高效率 协处理器。HBase 支持通过协处理器框架围绕 HBase 函数执行用户定义的生命周期钩子函数，从而有机会扩展功能并允许细粒度定制 过滤器。HBase 允许用户将过滤逻辑定义为过滤对象，并将过滤过程向下推送到服务器端，以避免不必要的数据产生 RPC 成本 MOB，中型对象存储侧重于优化大小介于 10 到 100 MB 之间的值 快照。在 HBase 中备份数据的方法之一，包括通过克隆现有快照来创建新表 复制。一个 HBase 集群中的数据可以通过同步更改历史记录（具体为预写日志）复制到另一个 HBase 集群 2 Hbase如何组织数据 HBase 中的表是半结构化的，这意味着必须在使用前定义列族。数据单元格由特定行键、特定列系列、确切的列限定符和时间戳（对于多版本单元格中的特定版本）唯一标识。数据稀疏地存储在 HBase 中，缺失的列根本不占用存储空间。 Hbase 支持多版本数据，这意味着“一个单元格”实际上由多个单元格组成，每个版本一个单元格，按时间戳降序排序。为了便于理解，可以粗略地将数据组织视为下面的 JSON 数组。 123456789101112131415161718192021222324252627282930313233343536373839// table name format：&quot;$&#123;namespace&#125;:$&#123;table&#125;&quot;// e.g. &quot;default:test_table&quot;[ &quot;rowKey1&quot;: &#123; // rowkey locates a row &quot;cf1&quot;: &#123; // column family must be pre-defined in table schema &quot;cq_a&quot;: &#123; // column qualifier can be arbitrary value &quot;timestamp3&quot;: &quot;value3&quot;, // a cell is located by (row=rowKey1, column=&quot;cf1:cf_a&quot;, timestamp=timestamp2) &quot;timestamp2&quot;: &quot;value2&quot;, &quot;timestamp1&quot;: &quot;value1&quot; &#125;, &quot;cq_b&quot;: &#123; &quot;timestamp2&quot;: &quot;value2&quot;, &quot;timestamp1&quot;: &quot;value1&quot; &#125; &#125;, &quot;cf3&quot;: &#123; &quot;cq_m&quot;: &#123; &quot;timestamp1&quot;: &quot;value1&quot; &#125;, &quot;cq_n&quot;: &#123; &quot;timestamp1&quot;: &quot;value1&quot; &#125; &#125;, &#125;, &quot;rowKey3&quot;: &#123; &quot;cf2&quot;: &#123; // sparse storage. missing column families take no storage space &quot;cq_x&quot;: &#123; &quot;timestamp3&quot;: &quot;value3&quot;, &quot;timestamp2&quot;: &quot;value2&quot;, &quot;timestamp1&quot;: &quot;value1&quot; &#125;, &quot;cq_y&quot;: &#123; &quot;timestamp1&quot;: &quot;value1&quot; &#125; &#125;, &#125;] HBase Architecture HBase 架构 Hbase 集群由以下组件组成 Zookeeper。为了在分布式系统中达成共识，Zookeeper 用于 HBase 主领导选举、服务发现和分布式任务管理等。 Master。HBase master 管理集群的元数据，并调度区域服务器，如存活检查、重新平衡等。只有 master 的 leader 实例负责，follower 实例处于备用状态，当 leader 关闭时通过 leader 选举接管，从而实现高可用。 Region Server。每个Region Server实例都在不相交的连续行键范围内提供数据，并且所有Region Server一起覆盖整个行键空间。 Thrift Server。HBase 还提供了一个 Thrift 协议来操作数据。Thrift 请求由 Thrift 服务器代理到Region Server。 3 HBase客户端如何执行读/写请求 HBase 客户端配置了与目标 HBase 集群对应的 Zookeeper 信息 客户端请求 Zookeeper 查找Region Server A 提供元数据表 ‘hbase：meta’ 然后，客户端请求区域服务器 A 在“hbase：meta”表中查找为目标行键提供服务的Region Server B 最后，客户端请求Region Server B 操作目标行键的数据 然后，位置信息将缓存在客户端中，以避免查找成本 4 当我们向 HBase 读取/写入数据时会发生什么？ HBase 实现了一种称为日志结构化合并树的数据结构。 当收到写入请求时，更改记录首先记录在预写日志中，该日志是持久存储在磁盘上的仅追加日志。然后将数据写入 MemTable，这是一种内存中的数据结构，可使行保持顺序，并支持二进制搜索和行的正向和反向迭代，通常由 ConcurrentSkipListMap 实现。 一旦 MemTable 的大小达到配置的阈值，就会触发刷新，将 MemTable 数据写入存储在 HDFS 上的 StoreFiles 中。顺便说一下，每个列系列都有自己的 MemTable 和 StoreFiles。 既然一个列族的数据可以存储在 MemTable 中，也可以存储在一个区域服务器内的多个 StoreFile 中，那么我们如何读取一行呢？构造一个合并的迭代器，将所有 StoreFile 和 MemTable 组合在一起，形成一个全局有序的视图。首先，为每个 StoreFile/MemTable 创建一个迭代器，该迭代器可以在 StoreFile/MemTable 中按顺序迭代行。其次，在这些迭代器上构造一个最小堆，使用比较器作为迭代器的当前行。因此，可以确保最小堆顶部的迭代器中的当前行是全局顺序的下一行。 HBase 中的预写日志 ConcurrentSkipListMap 的结构","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://binwenwu.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Hbase","slug":"Hbase","permalink":"https://binwenwu.github.io/tags/Hbase/"}]},{"title":"SSH建立原理及配置两台主机的远程连接实现免密登陆","slug":"SSH建立原理及配置两台主机的远程连接实现免密登陆","date":"2024-01-10T08:23:08.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/85912ba6/","link":"","permalink":"https://binwenwu.github.io/posts/85912ba6/","excerpt":"","text":"1 SSH原理 SSH是一种协议标准 SSH是用在安全远程登录以及其它安全网络服务 SSH为Secure Shell的缩写，默认端口22，由IETF的网络小组（Network Working Group）所制定；SSH为建立在应用层基础上的安全协议。SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH 2 非对称加密 SSH协议与telnet、ftp等协议主要的区别在于安全性。这就引出下一个问题：如何实现数据的安全呢？首先想到的实现方案肯定是对数据进行加密。加密的方式主要有两种： 对称加密（也称为密钥加密） 非对称加密（也称公钥加密） 对称加密原理：指加密解密使用同一套密钥。对称加密的加密强度高，很难破解。 但是在实际应用过程中不得不面临一个棘手的问题：如何安全的保存密钥呢？尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，非对称加密应运而生 下图是两台机器SSH免密登录的原理 3 免密设置 A上执行ssh-keygen -t rsa，三次回车。生成之后会在用户的根目录生成一个 “.ssh”的文件夹 查看.ssh下面的文件 1234authorized_keys : 存放远程免密登录的公钥,主要通过这个文件记录多台机器的公钥（初始不存在该文件） id_rsa : 生成的私钥文件 id_rsa.pub : 生成的公钥文件know_hosts : 已知的主机公钥清单 将A上的id_rsa.pub中的公钥拷贝至B中的authorized_keys 设置完成，现在A可以实现免密登录B，反之想要让B免密登录A则进行对应设置 4 注意事项 Linux服务器之间进行SSH互信免密登录时，文件及目录的权限有严格控制，不能过度授权 ~/.ssh目录权限为700 id_rsa：私钥，相当于“锁”，文件权限：600 id_rsa.pub：公钥，相当于“钥匙”，文件权限：644 authorized_keys：认证文件，记录别人给你的公钥，文件权限：600 known_hosts：”指纹文件“，记录首次SSH互信对端留给你的”指纹信息“，文件权限：600","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://binwenwu.github.io/tags/SSH/"}]},{"title":"Postgres展平JSON(b)","slug":"Postgres展平JSON(b)","date":"2024-01-01T14:56:08.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/2922fd2b/","link":"","permalink":"https://binwenwu.github.io/posts/2922fd2b/","excerpt":"","text":"开发人员喜欢使用 JSON，当他们存储数据时，通常不会对其进行规范化。 因此，在数据库中遇到 JSON(b) 字段并不罕见。 对于数据分析师、数据科学家和机器学习工程师来说，取消嵌套或扁平化，数据往往是后续分析的先决条件。 整理数据库中的 JSON 列可能具有挑战性。 通常目标是将 JSON 数组扩展到新行并将 JSON 对象取消嵌套到新列中。 幸运的是，Postgres 有几个内置函数，可以组合这些函数来处理数据库中复杂 JSON 的规范化。 1 数据集 下表说明了一个常见的场景，其中一个表（我们将其称为城市）包含一个 JSON 或 JSON(b) 列（即坐标）。 12345678910+---+-------------------+-------+---------------------------------+|idx|name |country|coordinates |+---+-------------------+-------+---------------------------------+|1 |Sant Julià de Lòria|AD |&#123;&quot;lat&quot;: 42.46372, &quot;lng&quot;: 1.49129&#125;||2 |Pas de la Casa |AD |&#123;&quot;lat&quot;: 42.54277, &quot;lng&quot;: 1.73361&#125;||3 |Ordino |AD |&#123;&quot;lat&quot;: 42.55623, &quot;lng&quot;: 1.53319&#125;||4 |les Escaldes |AD |&#123;&quot;lat&quot;: 42.50729, &quot;lng&quot;: 1.53414&#125;||5 |la Massana |AD |&#123;&quot;lat&quot;: 42.54499, &quot;lng&quot;: 1.51483&#125;||6 |Encamp |AD |&#123;&quot;lat&quot;: 42.53474, &quot;lng&quot;: 1.58014&#125;|+---+-------------------+-------+---------------------------------+ 虽然数据存储为 JSON 对象，但数据分析师、数据科学家或 ML 工程师更喜欢将 lat 和 lng 规范化为列。 幸运的是，我们可以使用 Postgres 内置的 jsonb_to_record 函数来构造 JSON 对象。 2 使用 jsonb_to_record 展平 JSON 对象 如果相关列包含 JSON(b) 对象，你可以使用内置函数 jsonb_to_record（或 json_to_record）将键值对规范化为列。 该函数接受一个 JSON 对象或包含 JSON 对象的列，并返回一条记录。 通过在 AS 表达式中匹配用户提供的复合类型来扩展记录。 复合类型表达式只是 JSON 对象键名（区分大小写）和用于它的 Postgres 数据类型。 JSON 对象可以包含比您在复合类型中定义的更多的键值对，它们将被排除。 如果复合类型定义了 JSON 对象中缺少的键，则它的值为 null。 Postgres 文档显示了如何在给定 JSON 对象的情况下使用 json_to_record： 123SELECT *FROM json_to_record(&#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:[1,2,3],&quot;c&quot;:&quot;bar&quot;&#125;&#x27;) AS x(a int, b text, d text) 123 a | b | d---+---------+--- 1 | [1,2,3] | 在此示例中，该函数接收一个 JSON 对象 {“a”:1,“b”:[1,2,3],“c”:“bar”}。 用户定义的复合类型 x 定义键 a、b 和 d 的映射。 因为 JSON 对象包含键 a 和 b，并且数据类型与复合类型中的数据类型匹配，所以它们被提取为记录的一部分。 复合类型没有为 c 定义映射，所以它不是从对象中提取的。 此外，复合类型定义了对象中缺少的 d，因此未被提取。 文档中的示例很好，但通常我们希望在表列而不是字符串中取消嵌套 JSON。 幸运的是，我们可以在包含 JSON 对象的列上使用相同的 json_to_record 和 jsonb_to_record 函数。 以上面的城市表为例，我们可以将坐标列中的 JSON 对象展平。 123456789SELECT city.idx, city.&quot;name&quot;, city.country, coord.lat, coord.lngFROM city, jsonb_to_record(coordinates) AS coord(lat numeric, lng numeric); 12345678910+---+-------------------+-------+--------+-------+|idx|name |country|lat |lng |+---+-------------------+-------+--------+-------+|1 |Sant Julià de Lòria|AD |42.46372|1.49129||2 |Pas de la Casa |AD |42.54277|1.73361||3 |Ordino |AD |42.55623|1.53319||4 |les Escaldes |AD |42.50729|1.53414||5 |la Massana |AD |42.54499|1.51483||6 |Encamp |AD |42.53474|1.58014|+---+-------------------+-------+--------+-------+ 在此示例中，我们在坐标列上使用 jsonb_to_record 将对象展平为两列。 复合类型坐标匹配对象键和数据类型。 然后，我们可以在 SELECT 语句中引用与复合类型匹配的记录，以将 lat 和 lng 作为单独的列返回。 3 使用 jsonb_to_recordset 取消嵌套 JSON 数组 如果你的数据是 JSON 数组而不是 JSON 对象，则不能使用 jsonb_to_record 对其进行规范化。 相反，您想使用相关函数 jsonb_to_recordset。 内置函数 json_to_recordset 和 jsonb_to_recordset 与对应的 json_to_record 和 jsonb_to_record 非常相似。 不同之处在于 *_to_recordset 函数对 JSON 数组而不是 JSON 对象进行操作。 为了说明这一点，请考虑下表（称为国家/地区）。 该表与上面的城市表类似，只是每个城市一行，每个国家一行。 cities 列包含一个 JSON 数组，其中每个条目都是一个城市，存储为 JSON 对象。 12345678910+---+------------+---------------------------------------------------------------+|idx|country_name|cities |+---+------------+---------------------------------------------------------------+|1 |AU |[&#123;&quot;name&quot;: &quot;York&quot;, &quot;coordinates&quot;: &#123;&quot;lat&quot;: -31.88809, &quot;lng&quot;: 1...||2 |AT |[&#123;&quot;name&quot;: &quot;Neu-Guntramsdorf&quot;, &quot;coordinates&quot;: &#123;&quot;lat&quot;: 48.0642...||3 |AR |[&#123;&quot;name&quot;: &quot;Zárate&quot;, &quot;coordinates&quot;: &#123;&quot;lat&quot;: -34.09814, &quot;lng&quot;:...||4 |AG |[&#123;&quot;name&quot;: &quot;Saint John’s&quot;, &quot;coordinates&quot;: &#123;&quot;lat&quot;: 17.12096, &quot;...||5 |AO |[&#123;&quot;name&quot;: &quot;Saurimo&quot;, &quot;coordinates&quot;: &#123;&quot;lat&quot;: -9.66078, &quot;lng&quot;:...||6 |AQ |[&#123;&quot;name&quot;: &quot;McMurdo Station&quot;, &quot;coordinates&quot;: &#123;&quot;lat&quot;: -77.846,...|+---+------------+---------------------------------------------------------------+ 在 cities 列上使用 jsonb_to_recordset 函数，我们可以将 JSON 数组扩展为单独的行。 和以前一样，我们提供了一个包含键名和数据类型的复合类型。 1234567SELECT idx, country_name, city.name, city.coordinatesFROM country, jsonb_to_recordset(cities) AS city(name text, coordinates jsonb); 12345678910+---+------------+---------+------------------------------------+|idx|country_name|name |coordinates |+---+------------+---------+------------------------------------+|1 |AU |York |&#123;&quot;lat&quot;: -31.88809, &quot;lng&quot;: 116.7678&#125; ||1 |AU |Yanchep |&#123;&quot;lat&quot;: -31.54678, &quot;lng&quot;: 115.63171&#125;||1 |AU |Yallingup|&#123;&quot;lat&quot;: -33.64592, &quot;lng&quot;: 115.03514&#125;||1 |AU |Wundowie |&#123;&quot;lat&quot;: -31.76163, &quot;lng&quot;: 116.3799&#125; ||1 |AU |Wooroloo |&#123;&quot;lat&quot;: -31.8038, &quot;lng&quot;: 116.31311&#125; ||1 |AU |Woodville|&#123;&quot;lat&quot;: -34.88333, &quot;lng&quot;: 138.55&#125; |+---+------------+---------+------------------------------------+ 请注意每个城市的 idx 值（国家/地区索引列）重复。 4 展平嵌套的 JSON 在前面的示例中，复合类型使用 jsonb 类型作为坐标键。 因此，查询将坐标作为 JSONB 列返回。 鉴于我们的目标是扁平化 JSON 数据，我们可以在之前的查询的基础上构建以返回单独的 lat 和 lng 列。 123456789SELECT idx, country_name, city.name, coord.lat, coord.lngFROM country, jsonb_to_recordset(cities) AS city(name text, coordinates jsonb), jsonb_to_record(coordinates) AS coord(lat numeric, lng numeric); 12345678910+---+------------+---------+---------+---------+|idx|country_name|name |lat |lng |+---+------------+---------+---------+---------+|1 |AU |York |-31.88809|116.7678 ||1 |AU |Yanchep |-31.54678|115.63171||1 |AU |Yallingup|-33.64592|115.03514||1 |AU |Wundowie |-31.76163|116.3799 ||1 |AU |Wooroloo |-31.8038 |116.31311||1 |AU |Woodville|-34.88333|138.55 |+---+------------+---------+---------+---------+ 同时使用 jsonb_to_recordset 和 jsonb_to_record，我们能够展平 JSON 数据，以便每个城市有一行，重复国家数据。 5 结束语 在数据库中争论 JSON 的数据分析师、数据科学家和 ML 工程师可以使用 Postgres 的内置函数来规范化数据。 通过将这些函数组合在一起，可以将复杂的 JSON 扩展为新的行和列，以便它们可以在下游用于数据探索、数据分析和构建模型。 原文链接：Flattening JSON(b) in Postgres","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Postgres","slug":"Postgres","permalink":"https://binwenwu.github.io/tags/Postgres/"}]},{"title":"3DTiles官方资源下载链接","slug":"3DTiles官方资源下载链接","date":"2024-01-01T13:56:08.000Z","updated":"2025-05-17T05:51:06.586Z","comments":true,"path":"posts/6005debc/","link":"","permalink":"https://binwenwu.github.io/posts/6005debc/","excerpt":"","text":"本文列出Cesium官方提供的 3DTiles 1.0和1.1规范的9个示例切块集（tileset） 有关如何使用本地服务器托管这些示例的详细信息，请参阅 INSTRUCTIONS.md 1 Metadata Granularities Metadata Granularities这个3DTiles 1.1 示例演示了 中元数据在不同粒度级别的使用。 该示例由具有 4 个切块的tileset组成，其中每个切块有 5 个内容，并且这些内容被分配到两个不同的组。 元数据被分配给切块集、切块、每个内容以及组。 下载地址：Metadata Granularities Tileset 2 Sparse Implicit Quadtree Sparse Implicit Quadtree是使用3DTiles 1.1的隐式平铺来表示小型稀疏四叉树的示例tileset。 四叉树有 6 个可用级别，每个子树有 3 个级别。 第 5 级中有 32 个可用切块。每个切块都有一个内容，这是一个简单的 glTF 资源，作为 GLB（glTF 二进制）文件，仅包含与相应切块范围相对应的单位正方形的一部分 。 除了具有内容的切块及其各自的祖先之外，没有其他切块可用。 下图显示了tileset的 6 个级别。 可用的tile包含 1，并显示为绿色。 不可用的tile包含 0，并显示为红色。 包含内容的单元格标记为 1+（仅在级别 5 中）。 subtreeInfo.md 中汇总了 .subtree 文件的 JSON 部分以及存储在二进制缓冲区中的可用性信息。 下载地址：Sparse Implicit Quadtree Tileset 3 Sparse Implicit Octree Sparse Implicit Octree是使用3DTiles 1.1的隐式平铺来表示小型稀疏八叉树的示例切块集。 八叉树有 6 个可用级别，每个子树有 3 个级别。 树中有 31 个包含内容的图块： 第 1 层有 1 个切块 第 2 层有 2 个切块 第 3 级有 4 个切块 第 4 级有 8 个切块 第5 级 有16 个切块 每个内容都是一个简单的 glTF 资源，作为 GLB（glTF 二进制）文件，仅包含与相应切块范围相对应的单位立方体的一部分。 除了具有内容的切块及其各自的祖先之外，没有其他切块可用。 下载地址：Sparse Implicit Octree Tileset 4 Multiple Contents 此示例演示了3DTiles 1.1如何在单个切块中存储多个内容对象。 Tileset的根切块包含一个模型，即具有正弦波的简单平面，有两种不同的表示形式： 作为纹理三角形网格 glTF 资源的低分辨率表示 具有顶点颜色的高分辨率点网格表示，作为另一个 glTF 资源 下载地址：Multiple Contents Tileset 5 Bounding Box Tests Bounding Box Tests是一个将单个简单 glTF 模型嵌入到3DTiles 1.1的tileset中的示例切块集，并显示相应 glTF 包围体的适当切块集包围体。 该目录包含六个不同的图块集，每个图块集都有一个 glTF 资源。 资产和目录是根据模型的包围体命名的，以最小和最大点的形式给出： (0,0,0) - (1,1,2) (0,0,0) - (1,2,1) (0,0,0) - (2,1,1) (0,0,2) - (1,1,4) (0,2,0) - (1,4,1) (2,0,0) - (4,1,1) 下载地址：Bounding Box Tests Tileset 6 Tileset with full Metadata 此示例根据 3DTiles 1.1的元数据规范中定义的类型系统演示了可能与实体关联的元数据类型。 该示例包含一个仅存储元数据的切块集，其中包含一个模式和一个元数据实体，两者都涵盖了所有可能的属性类型： 类型为 STRING、BOOLEAN 和 ENUM 的单个属性 具有所有数字组件类型 UINT8、INT8、UINT16、INT16、UINT32、INT32、UINT64、INT64、FLOAT32、FLOAT64 的单一 (SCALAR) 属性 复合类型 VEC2、VEC3、VEC4、MAT2、MAT3 和 MAT4，以及所有数字组件类型 具有所有组件类型的数组，一次具有固定长度，一次具有动态长度 所有整数分量类型都以标准化形式使用一次，以非标准化形式使用一次 下载地址：Tileset With Full Metadata 7 Tileset with discrete LODs 这是一个3DTiles 1.0示例，包含三个切块，每个切块都包含不同程度轻量化的斯坦福龙网格模型。 根切块 - 高度简化的龙 子切块 - 中度简化的龙 孙切块-原始的龙 当满足图块的屏幕空间错误时，它将被其更高 LOD 子级替换。 下载地址：Tileset with discrete LODs 8 Tileset With Request Volume 这个3DTiles 1.0 切块集显示切块的 requestVolume 属性。 当查看器位于点云的请求体积内时，将渲染点云。 此外，此示例说明了从主tileset.json 中加载外部tileset。 下载地址：Tileset With Request Volume 9 Tileset With Tree Billboards 这个 3DTiles 1.0切块集包含两个切块，一个具有完整 3D 树的 .i3dm，另一个具有 2D 广告牌树的 .i3dm。 缩小时，3D 树会被广告牌取代。 注意：广告牌效果被编码到 i3dm 的嵌入式 glTF 模型中，但使用矢量切片也可以实现类似的效果。 下载地址：Tileset With Tree Billboards 原文链接：Sample tilesets for learning how to use 3D Tiles","categories":[{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/categories/GIS/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/tags/GIS/"},{"name":"3DTiles","slug":"3DTiles","permalink":"https://binwenwu.github.io/tags/3DTiles/"}]},{"title":"yum无法拉取到镜像资源","slug":"yum无法拉取到镜像资源","date":"2023-11-09T13:59:05.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/e51b1ecb/","link":"","permalink":"https://binwenwu.github.io/posts/e51b1ecb/","excerpt":"","text":"今天在Linux上使用yum时，遇到如下这个问题，当时首先检查了网络，能够正常ping通百度，接着我又怀疑是DNS服务器没有设置或设置的DNS服务器无法解析一些域名，因此我又尝试切换了几大DNS服务器，但是也没有解决问题，DNS服务器和网关都能ping通，实在令人不解，最后也是没有办法，采取了比较傻瓜式的办法，我直接用能够正常使用的yum的缓存文件去替换掉无法正常使用的yum的缓存配置文件，因为yum的缓存文件中包含有镜像源软件包的元数据信息 1 问题 123456789101112131415161718192021222324252627282930313233Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was14: curl#7 - &quot;Failed connect to mirrorlist.centos.org:80; Operation now in progress&quot;One of the configured repositories failed (Unknown),and yum doesn&#x27;t have enough cached data to continue. At this point the onlysafe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this: 1. Contact the upstream for the repository and get them to fix the problem. 2. Reconfigure the baseurl/etc. for the repository, to point to a working upstream. This is most often useful if you are using a newer distribution release than is supported by the repository (and the packages for the previous distribution release still work). 3. Run the command with the repository temporarily disabled yum --disablerepo=&lt;repoid&gt; ... 4. Disable the repository permanently, so yum won&#x27;t use it by default. Yum will then just ignore the repository until you permanently enable it again or use --enablerepo for temporary usage: yum-config-manager --disable &lt;repoid&gt; or subscription-manager repos --disable=&lt;repoid&gt; 5. Configure the failing repository to be skipped, if it is unavailable. Note that yum will try to contact the repo. when it runs most commands, so will have to try and fail each time (and thus. yum will be be much slower). If it is a very temporary problem though, this is often a nice compromise: yum-config-manager --save --setopt=&lt;repoid&gt;.skip_if_unavailable=trueCannot find a valid baseurl for repo: base/7/x86_64 2 解决办法 替换yum缓存文件 （/var/cache/yum）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/tags/Linux/"},{"name":"yum","slug":"yum","permalink":"https://binwenwu.github.io/tags/yum/"}]},{"title":"Nginx搭建静态资源服务器","slug":"Nginx搭建静态资源服务器","date":"2023-11-01T01:20:52.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/85b8b565/","link":"","permalink":"https://binwenwu.github.io/posts/85b8b565/","excerpt":"","text":"1 nginx.conf文件中配置 假设静态资源放在服务器 /home/data/ 12345678910111213141516171819202122232425262728293031user root; # 启动用户worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; # 打开gzip压缩，可以减少带宽 server &#123; listen 80; # 1.指定端口 server_name dlib; # 2.服务名 location /data/ &#123; alias /home/data/; # 3.指定静态文件目录 autoindex on; # 自动索引 &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 或者 12345678910111213141516171819202122232425262728293031user root; # 启动用户worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; # 打开gzip压缩，可以减少带宽 server &#123; listen 80; # 1.指定端口 server_name dlib; # 2.服务名 location /data/ &#123; root /home/; # 3.指定静态文件目录 autoindex on; # 自动索引 &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 重启nginx 1nginx -s reload 访问：http://yourIP:80/data/ 2 二者区别 在Nginx配置中，alias 和 root 是两个用于指定文件系统路径的指令，但它们在用法和行为上有一些重要的区别： alias alias 指令用于将 URL 路径的一部分映射到文件系统的不同位置。 它允许你将 URL 中的一部分路径与文件系统中的完全不同的路径关联起来。 alias 通常用于创建虚拟目录，其中 URL 中的路径部分与文件系统中的路径不一致。 当使用 alias 时，Nginx会将 URL 路径与 location 块中指定的 alias 路径拼接在一起，然后在文件系统中查找文件。 1234nginxCopy codelocation /images/ &#123; alias /var/www/images/;&#125; 在上述示例中，如果访问 http://yourdomain.com/images/pic.jpg，Nginx会查找 /var/www/images/pic.jpg。 root root 指令用于设置一个目录，该目录是请求的 URL 路径的基础部分。 它将 URL 路径直接映射到文件系统中的路径，URL 路径的开头部分与文件系统路径一致。 root 通常用于将请求直接映射到文件系统中的目录，而不需要额外的路径拼接。 当使用 root 时，Nginx会将 URL 路径直接映射到指定的根目录。 1234nginxCopy codelocation /data/ &#123; root /var/www/;&#125; 在上述示例中，如果访问 http://yourdomain.com/data/file.txt，Nginx会查找 /var/www/data/file.txt。 总结：alias 用于创建虚拟目录，可以将 URL 路径与文件系统中的不同路径关联，而 root 用于将 URL 路径直接映射到文件系统中的目录。你可以根据需要选择合适的指令来配置 Nginx 以满足你的要求。","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://binwenwu.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"nginx","slug":"nginx","permalink":"https://binwenwu.github.io/tags/nginx/"}]},{"title":"PostgreSQL数据恢复方案","slug":"PostgreSQL数据恢复方案","date":"2023-10-27T01:20:52.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/dda2580a/","link":"","permalink":"https://binwenwu.github.io/posts/dda2580a/","excerpt":"","text":"1 问题 存在docker或者服务器上（无论是windows还是linux）的PostgreSQL无法启动，需要对数据进行恢复 2 解决 2.1 参考 云数据库 PostgreSQL 在云服务器上恢复 PostgreSQL 数据-操作指南https://cloud.tencent.com/document/product/409/11642 2.2 导出数据目录 ​ 找到“.../data”目录下所有的数据文件，如下图所示（注意并不是所有数据文件都长这样，因版本、软件和操作系统不同而异，但是绝大多数文件相同，故只列出了以下这些）。一般这些文件位于PostgreSQL的../data/目录，可以自行查找（网络，或者find命令查找postgresql.conf，在里面的data_directory会告诉你真的物理存储在哪），记得删除多余的临时文件。 2.3 搭建PostgreSQL ​ 在一个没有任何PostgreSQL的服务器上搭建跟原先版本一模一样的PostgreSQL（有postgis也得安装到位），这步也可以使用虚拟机来搭建，但是千万别用docker这类软件。 2.4 使用postgres用户创建恢复目录 切换为postgres用户，在云服务器中创建恢复目录recovery 1mkdir /var/lib/pgsql/10/recovery 其中，recovery 为示例目录，用户可自行修改恢复目录。后续示例中不同版本目录名将不再区分描述，请以实际为准，如PostgreSQL 10.x 均为/var/lib/pgsql/10，PostgreSQL 9.5.x 均为/var/lib/pgsql/9.5。 PostgreSQL 9.5 版本命令如下： 1mkdir /var/lib/pgsql/9.6/recovery PostgreSQL 14 版本命令如下： 1mkdir /var/lib/PostgreSQL/14/recovery 2.5 修改配置文件 将配置文件PostgreSQL.conf中的以下选项注释掉，注释方法：在行首使用#。如有多个该选项，则全部注释掉（说明：如果恢复版本为 PostgreSQL 12.4，还需要注释 include = 'standby.conf' 这一行） 12345678shared_preload_librarieslocal_preload_librariespg_stat_statements.maxpg_stat_statements.trackarchive_modearchive_commandsynchronous_commitsynchronous_standby_names 修改配置文件PostgreSQL.conf 12port = &#x27;5432&#x27; # 将port参数的值修改为5432unix_socket_directories = &#x27;/var/run/PostgreSQL/&#x27; # 将unix_socket_directories的值修改为/var/run/PostgreSQL/， # 如未设置此值，可跳过此项 在PostgreSQL.conf文件末尾追加配置，表示不再使用强同步模式 12synchronous_commit = localsynchronous_standby_names = &#x27;&#x27; 添加pg_hba.conf 可以在安装好的数据库位置下，大概是/usr/pgsql-10/bin/pg_hba.conf(可能版本不同路径不同，但绝大多数是)，找到pg_hba.conf。然后cp到recovery/。可能要vim进行修改一下，主要是port需要设置成默认的5432。 最后配置结果如下所示: 2.6 使用root用户更改文件夹权限 12chmod 0700 /var/lib/pgsql/10（版本号）/recoverychown postgres:postgres /var/lib/pgsql/10（版本号）/recovery -R 2.7 使用postgres用户启动数据库 1/usr/pgsql-10/bin/pg_ctl start -D /var/lib/pgsql/10/recovery 如果没有server start那就挨个去看log信息，可能是某个配置文件没有找到（那就在main里面或者原来数据库的安装位置中寻找，然后cp），可能是端口。 2.8 登陆数据库验证 查看版本 12export PGDATA=/var/lib/pgsql/10（版本号）/recoverypsql 验证运行 如提示server is running，则代表数据库正在运行 1/usr/pgsql-10（自定义）/bin/pg_ctl status -D /var/lib/pgsql/10（版本号）/recovery 2.9 通过手动导出数据进行恢复 您也可以手动导出备份数据，然后在服务器上进行恢复操作，该方案在 Windows 和 Linux 下同样适用，与物理文件所在的文件系统无关 在云服务器下 dump 出数据，示例如下： 若数据较大，可通过 -Fc 指定为二进制文件 1234# 命令格式为：pg_dump -h &lt;访问IP&gt; -U &lt;访问用户&gt; -f &lt;备份文件全路径&gt; -c -C &lt;导出的数据库名&gt;# Example：/usr/pgsql-10/bin/pg_dump -h 192.168.0.16(可不要) -U testroot -f backup.sql -c -C postgres 服务器上恢复数据 进入PostgreSQL安装目录的bin文件夹下(例如，/usr/pgsql-14/bin/)，使用psql工具进行数据恢复。 1./psql -p 端口号 -U 用户名 -W -f ../backup.sql 其中这里端口号自定义，用户名建议都换成旧数据库一样的名称（如果没有，记得先创建被赋予超级权限） 说明：因为有 pg_stat_error 等插件，可能会导致报错，但不影响数据导入。只要能运行下去不报错停止就行","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://binwenwu.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"https://binwenwu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"通过原始存储配置文件恢复数据库（简单粗暴）","slug":"通过原始存储配置文件恢复数据库（简单粗暴）","date":"2023-10-12T01:20:52.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/add5de83/","link":"","permalink":"https://binwenwu.github.io/posts/add5de83/","excerpt":"","text":"本文方法为作者自己尝试得出，不一定有效，若失败，还请参考正规的解决方案 本文的三种数据库恢复都以Docker来进行恢复，即本文会用Docker创建相应的数据库容器来对需要恢复的数据库进行恢复，在删除配置文件时，需要查看一些配置文件内容是否与需要恢复的数据库相同，如K8S集群中创建的数据库与Docker中创建的pg数据库就不同，postmaster.pid等文件内容 1 MongoDB 找到需要恢复的数据库的存储配置文件，如下图所示 拉取MongoDB镜像，版本最好要对应，这里就以安装最新版本为例 1docker pull mongo 生成容器 -d：后台启动模式，不会占用终端 -p：主机端口:容器内端口 --name：容器名称 -v：指定了主机文件系统路径 /mnt/storage/wbw-mongo/data 和容器内部路径 /data/db 之间的卷映射。这个映射用于将 MongoDB 数据库数据存储在主机上，以便数据持久性。容器内的数据将被存储在主机的 /mnt/storage/wbw-mongo/data 目录中 1docker run -d -p 31074:27017 --name wbw-mongo -v /mnt/storage/wbw-mongo/data:/data/db mongo:latest 删除刚刚生成的存储配置文件 注意，不要直接删除data文件夹，而是将data内的文件全部删除 1rm -rf /mnt/storage/wbw-mongo/data/* 将需要恢复的数据库的存储配置文件复制到/mnt/storage/wbw-mongo/data/下，假设需要恢复的数据库的存储配置文件位置为/mnt/storage/bak-mongo/data/ 1cp /mnt/storage/bak-mongo/data/* /mnt/storage/wbw-mongo/data/ 重启容器 1docker restart wbw-mongo 恢复结束 2 MySQL 找到需要恢复的数据库的存储配置文件，如下图所示 拉取MySQL镜像，版本最好要对应，这里就以安装最新版本为例 1docker pull mysql 生成容器 1docker run -d -p 30491:3306 --name wbw-mysql -e MYSQL_ROOT_PASSWORD=123456 -v /mnt/storage/wbw-mysql/data:/var/lib/mysql mysql:latest 删除刚刚生成的存储配置文件 1rm -rf /mnt/storage/wbw-mysql/data/* 将需要恢复的数据库的存储配置文件复制到/mnt/storage/wbw-mysql/data/下，假设需要恢复的数据库的存储配置文件位置为/mnt/storage/bak-mysql/data/ 1cp /mnt/storage/bak-mysql/data/* /mnt/storage/wbw-mysql/data/ 重启容器 1docker restart wbw-mysql 恢复结束 3 PostgreSQL 找到需要恢复的数据库的存储配置文件，如下图所示 拉取PostgreSQL镜像，版本最好要对应，这里就以安装14为例 1docker pull postgres:14 生成容器 1docker run -d --name wbw-postgres -v /mnt/storage/wbw-postgres/data:/var/lib/postgresql/data -e POSTGRES_PASSWORD=123456 -p 5432:5432 postgres:14 删除刚刚生成的存储配置文件 1rm -rf /mnt/storage/wbw-postgres/data/* 将需要恢复的数据库的存储配置文件复制到/mnt/storage/postgresql/data/下，假设需要恢复的数据库的存储配置文件位置为/mnt/storage/bak-postgresql/data/ 1cp /mnt/storage/bak-postgres/data/* /mnt/storage/wbw-postgres/data/ 重启容器 1docker restart wbw-postgres 恢复结束","categories":[{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://binwenwu.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://binwenwu.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"https://binwenwu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Microsoft Office下载及激活教程","slug":"Microsoft Office下载及激活教程","date":"2023-10-11T12:10:50.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/499a3852/","link":"","permalink":"https://binwenwu.github.io/posts/499a3852/","excerpt":"","text":"1 Office Tool Plus下载 下载链接 Office Tool Plushttps://otp.landian.vip/zh-cn/download.html 下载包含框架版本 解压后双击运行Office Tool Plus.exe 2 安装Office 若曾经安装过Office，则需要完全卸载，若卸载遇到问题，可以使用Office Tool Plus工具箱中的卸载工具进行卸载 点击左侧部署，根据自己的需求进行设置 在下面的产品对话框点击添加产品，选择Microsoft 365 企业应用版 然后勾选自己想要安装的产品 点击开始部署即可开始安装 3 激活Office 点击左侧激活选项，在许可证管理选项卡点击安装许可证，选择带有批量许可证的选项，然后点击确定 许可证安装完成，点击KMS管理，保存设置，若该KMS主机报错，可以在以下链接找合适的：KMS 列表 点击激活即可","categories":[{"name":"日常办公","slug":"日常办公","permalink":"https://binwenwu.github.io/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"https://binwenwu.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Office","slug":"Office","permalink":"https://binwenwu.github.io/tags/Office/"},{"name":"Windows","slug":"Windows","permalink":"https://binwenwu.github.io/tags/Windows/"}]},{"title":"Docker安装PostgreSQL并添加PostGIS拓展","slug":"Docker安装PostgreSQL并添加PostGIS拓展","date":"2023-10-09T12:20:52.000Z","updated":"2025-05-17T05:51:06.588Z","comments":true,"path":"posts/e232bc22/","link":"","permalink":"https://binwenwu.github.io/posts/e232bc22/","excerpt":"","text":"1 下载镜像 访问dockerhub官网：https://registry.hub.docker.com/ 地址，下载指定版本的PostgreSQL数据库。 下载 1docker pull postgres:14 查看 1docker images 2 镜像转为容器 1docker run -d --restart=always --name postgres -v /mnt/storage/postgresql/data:/var/lib/postgresql/data -e POSTGRES_PASSWORD=123456 -p 5432:5432 postgres:14 docker run: 这是Docker命令的开头，用于运行一个容器。 -d: 这是一个标志，表示容器应以后台模式运行（detached mode），这意味着容器将在后台运行，不会占用终端。 --restart=always: 这是一个标志，指定容器在退出时应该始终自动重新启动。如果容器不期望停止运行，这可以确保容器总是在它退出时重新启动。 --name postgres: 这是一个标志，为容器指定了一个名称，即&quot;postgres&quot;。这使得容器可以通过这个名称来引用，而不必使用容器ID。 -v /mnt/storage/postgresql/data:/var/lib/postgresql/data: 这是一个标志，指定了主机文件系统路径/mnt/storage/postgresql/data和容器内部路径/var/lib/postgresql/data之间的卷映射。这个映射用于将PostgreSQL数据库数据存储在主机上，以便数据持久性。容器内的数据将被存储在主机的/mnt/storage/postgresql/data目录中。 -e POSTGRES_PASSWORD=123456: 这是一个标志，用于设置PostgreSQL数据库的密码。在这个例子中，密码被设置为&quot;123456&quot;，这是一个示例密码。你可以根据需要更改它。 -p 5432:5432: 这是一个标志，用于将主机端口5432映射到容器内的端口5432。这是PostgreSQL数据库默认监听的端口。通过这个映射，你可以在主机上通过5432端口访问容器内运行的PostgreSQL数据库。 postgres:14: 这是要运行的Docker镜像的名称和标签。在这里，使用的是PostgreSQL 14版本的官方Docker镜像。Docker将下载并运行此镜像以创建容器。 一旦运行此命令，Docker将创建一个PostgreSQL容器，该容器以后台模式运行，具有指定的名称postgres，将数据存储在主机上的/mnt/storage/postgresql/data目录中，使用指定的密码，同时将主机端口5432映射到容器内的5432端口上。容器将在退出时自动重新启动，以确保持续可用性。 3 添加PostGIS拓展 进入容器 1docker exec -it ca24dbe6f3d7 bash 更新软件包列表 1apt update 使用apt在线安装PostGIS（注意版本要和PostgreSQL兼容） 1apt install postgresql-14-postgis-3 postgresql-14-postgis-3-dbgsym postgresql-14-postgis-3-scripts 使用Navicat等客户端软件连接到PostgreSQL，并新建查询，输入以下SQL语句，点击执行 12CREATE EXTENSION postgis;SELECT postgis_full_version(); 出现类似如下查询结果即为成功 1POSTGIS=&quot;3.4.0 0874ea3&quot; [EXTENSION] PGSQL=&quot;140&quot; GEOS=&quot;3.11.1-CAPI-1.17.1&quot; PROJ=&quot;9.1.1 NETWORK_ENABLED=OFF URL_ENDPOINT=https://cdn.proj.org USER_WRITABLE_DIRECTORY=/var/lib/postgresql/.local/share/proj DATABASE_PATH=/usr/share/proj/proj.db&quot; LIBXML=&quot;2.9.14&quot; LIBJSON=&quot;0.16&quot; LIBPROTOBUF=&quot;1.4.1&quot; WAGYU=&quot;0.5.0 (Internal)&quot;","categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://binwenwu.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://binwenwu.github.io/tags/PostgreSQL/"},{"name":"PostGIS","slug":"PostGIS","permalink":"https://binwenwu.github.io/tags/PostGIS/"},{"name":"数据库","slug":"数据库","permalink":"https://binwenwu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Docker镜像打包迁移","slug":"Docker镜像打包迁移","date":"2023-10-09T01:20:52.000Z","updated":"2025-05-17T05:51:06.588Z","comments":true,"path":"posts/620cff7f/","link":"","permalink":"https://binwenwu.github.io/posts/620cff7f/","excerpt":"","text":"要将 Docker 镜像从一台服务器传输到另一台服务器，您可以使用以下步骤： 1 导出 Docker 镜像： 首先，在源服务器上导出您要传输的 Docker 镜像。使用以下命令将镜像导出为一个文件： 1docker save -o image.tar image_name:tag 其中 image_name:tag 是您要导出的 Docker 镜像的名称和标签。此命令将创建一个名为 image.tar 的镜像文件。 2 传输 Docker 镜像文件 将导出的 Docker 镜像文件 image.tar 从源服务器传输到目标服务器。您可以使用各种方法，如SCP、SFTP、rsync 或者将文件上传到云存储服务（如Amazon S3、Google Cloud Storage）等方式来传输文件。 3 导入 Docker 镜像 在目标服务器上导入传输过来的 Docker 镜像文件。使用以下命令来导入镜像： 1docker load -i image.tar 这将从 image.tar 文件中加载镜像到目标服务器的 Docker 环境中。 4 验证导入的 Docker 镜像 您可以使用以下命令来验证在目标服务器上成功导入了镜像： 1docker images 这将列出在目标服务器上可用的 Docker 镜像，确保您的镜像已成功导入。 现在，您已经成功将 Docker 镜像从一台服务器传输到另一台服务器。请注意，在进行这些操作时，确保您有足够的权限来执行 Docker 命令和文件传输操作，并且在网络连接方面没有限制。另外，确保目标服务器上的 Docker 环境与源服务器兼容，以便正常运行您的镜像。","categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://binwenwu.github.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"Vue子组件中调用父组件中的方法","slug":"Vue子组件中调用父组件中的方法","date":"2023-08-12T09:59:05.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/aec1e412/","link":"","permalink":"https://binwenwu.github.io/posts/aec1e412/","excerpt":"","text":"在Vue中，子组件可以通过事件(Event)机制与父组件进行通信，从而调用父组件中的方法。以下是一种常见的方法： 1 在父组件中定义方法 首先，在父组件中定义一个方法 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;callParentMethod&quot;&gt;调用父组件方法&lt;/button&gt; &lt;child-component @custom-event=&quot;handleCustomEvent&quot;&gt;&lt;/child-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComponent from &#x27;./ChildComponent.vue&#x27;;export default &#123; components: &#123; ChildComponent &#125;, methods: &#123; callParentMethod() &#123; console.log(&#x27;父组件的方法被调用&#x27;); &#125;, handleCustomEvent(payload) &#123; console.log(&#x27;自定义事件在父组件被触发，数据：&#x27;, payload); &#125; &#125;&#125;;&lt;/script&gt; 2 在子组件中触发事件 在子组件中，通过$emit方法触发一个自定义事件，从而与父组件通信 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;callParentMethod&quot;&gt;调用父组件方法&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; callParentMethod() &#123; this.$emit(&#x27;custom-event&#x27;, &#123; data: &#x27;来自子组件的数据&#x27; &#125;); &#125; &#125;&#125;;&lt;/script&gt; 在这个例子中，当子组件中的按钮被点击时，callParentMethod方法会调用this.$emit('custom-event', ...)，触发一个名为custom-event的自定义事件，并传递一个数据对象作为参数。 3 在父组件中监听事件 在父组件的模板中使用@custom-event来监听子组件发出的事件，并在相应的处理方法中调用父组件的方法 通过这种方式，子组件就能够调用父组件中的方法，实现了子组件与父组件之间的通信。记住，事件名custom-event应该在父组件中监听和子组件中触发时保持一致。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://binwenwu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://binwenwu.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://binwenwu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"组件","slug":"组件","permalink":"https://binwenwu.github.io/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"Linux 系统字体安装","slug":"Linux 系统字体安装","date":"2023-08-09T11:48:15.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/2de821dc/","link":"","permalink":"https://binwenwu.github.io/posts/2de821dc/","excerpt":"","text":"在安装之前可以先使用命令 fc-list :lang=zh 查看已经安装的中文字体，最后安装后还使用该命令查看新安装的字体 1、创建目录 在Linux中创建目录 /usr/share/fonts/myfonts 2、拷贝字体 将Windows下的字体拷贝到myfonts目录中。 Windows 中的字体在目录 C:\\Windows\\Fonts 中，选择你需要的字体拷贝。 3、目录权限设置 为myfonts目录设置权限 1chmod 755 myfonts 4、安装字体索引指令 在centos上，使用如下命令进行安装 1yum install -y fontconfig mkfontscale 在ubuntu上，使用如下命令进行安装 1sudo apt-get -y install fontconfig xfonts-utils 5、建立字体索引信息更新字体缓存 进入myfonts目录安装字体，建立索引更新缓存 12cd /usr/share/fonts/myfontsmkfontscale &amp;&amp; mkfontdir &amp;&amp; fc-cache -fv 6、验证结果 验证字体是否安装成功 1fc-list :lang=zh","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/tags/Linux/"},{"name":"安装","slug":"安装","permalink":"https://binwenwu.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"Linux上Pandoc的使用","slug":"Linux上Pandoc的使用","date":"2023-08-09T10:25:15.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/557acb69/","link":"","permalink":"https://binwenwu.github.io/posts/557acb69/","excerpt":"","text":"如果你需要在不同的文件格式之间相互转换，多半听说或使用过文档转换的瑞士军刀——Pandoc。事实上，不仅人类知道 Pandoc，最近很火的人工智能 ChatGPT 也知道「将 Markdown 转换为 docx」，首选方案是使用 Pandoc。 Pandoc 官网https://www.pandoc.org/ 1 安装 下载压缩包 1wget https://github.com/jgm/pandoc/releases/download/2.14.0.3/pandoc-2.14.0.3-linux-amd64.tar.gz 解压 1tar -xvf pandoc-2.14.0.3-linux-amd64.tar.gz 建立软链接 1ln -s /root/pandoc-2.14.0.3/bin/pandoc /usr/bin/pandoc latex引擎安装 1yum install texlive-xetex 查看版本 1pandoc -v 2 使用 To see the output created by each of the commands below, click on the name of the output file: HTML fragment 1pandoc MANUAL.txt -o example1.html Standalone HTML file 1pandoc -s MANUAL.txt -o example2.html HTML with table of contents, CSS, and custom footer 1pandoc -s --toc -c pandoc.css -A footer.html MANUAL.txt -o example3.html LaTeX 1pandoc -s MANUAL.txt -o example4.tex From LaTeX to markdown 1pandoc -s example4.tex -o example5.text reStructuredText 1pandoc -s -t rst --toc MANUAL.txt -o example6.text Rich text format (RTF) 1pandoc -s MANUAL.txt -o example7.rtf Beamer slide show 1pandoc -t beamer SLIDES -o example8.pdf DocBook XML 1pandoc -s -t docbook MANUAL.txt -o example9.db Man page 1pandoc -s -t man pandoc.1.md -o example10.1 ConTeXt 1pandoc -s -t context MANUAL.txt -o example11.tex Converting a web page to markdown 1pandoc -s -r html http://www.gnu.org/software/make/ -o example12.text From markdown to PDF 1pandoc MANUAL.txt --pdf-engine=xelatex -o example13.pdf PDF with numbered sections and a custom LaTeX header 1pandoc -N --variable &quot;geometry=margin=1.2in&quot; --variable mainfont=&quot;Palatino&quot; --variable sansfont=&quot;Helvetica&quot; --variable monofont=&quot;Menlo&quot; --variable fontsize=12pt --variable version=2.0 MANUAL.txt --include-in-header fancyheaders.tex --pdf-engine=lualatex --toc -o example14.pdf ipynb (Jupyter notebook) 1pandoc example15.md -o example15.ipynb HTML slide shows 12345pandoc -s --mathml -i -t dzslides SLIDES -o example16a.htmlpandoc -s --webtex -i -t slidy SLIDES -o example16b.htmlpandoc -s --mathjax -i -t revealjs SLIDES -o example16d.html TeX math in HTML 123456789pandoc math.text -s -o mathDefault.htmlpandoc math.text -s --mathml -o mathMathML.htmlpandoc math.text -s --webtex -o mathWebTeX.htmlpandoc math.text -s --mathjax -o mathMathJax.htmlpandoc math.text -s --katex -o mathKaTeX.html Syntax highlighting of delimited code blocks 12345678910111213pandoc code.text -s --highlight-style pygments -o example18a.htmlpandoc code.text -s --highlight-style kate -o example18b.htmlpandoc code.text -s --highlight-style monochrome -o example18c.htmlpandoc code.text -s --highlight-style espresso -o example18d.htmlpandoc code.text -s --highlight-style haddock -o example18e.htmlpandoc code.text -s --highlight-style tango -o example18f.htmlpandoc code.text -s --highlight-style zenburn -o example18g.html GNU Texinfo 1pandoc MANUAL.txt -s -o example19.texi OpenDocument XML 1pandoc MANUAL.txt -s -t opendocument -o example20.xml ODT (OpenDocument Text, readable by OpenOffice) 1pandoc MANUAL.txt -o example21.odt MediaWiki markup 1pandoc -s -t mediawiki --toc MANUAL.txt -o example22.wiki EPUB ebook 1pandoc MANUAL.txt -o MANUAL.epub Markdown citations 12345pandoc -s --bibliography biblio.bib --citeproc CITATIONS -o example24a.htmlpandoc -s --bibliography biblio.json --citeproc --csl chicago-fullnote-bibliography.csl CITATIONS -o example24b.htmlpandoc -s --bibliography biblio.yaml --citeproc --csl ieee.csl CITATIONS -t man -o example24c.1 Textile writer 1pandoc -s MANUAL.txt -t textile -o example25.textile Textile reader 1pandoc -s example25.textile -f textile -t html -o example26.html Org-mode 1pandoc -s MANUAL.txt -o example27.org AsciiDoc 1pandoc -s MANUAL.txt -t asciidoc -o example28.txt Word docx 1pandoc -s MANUAL.txt -o example29.docx LaTeX math to docx 1pandoc -s math.tex -o example30.docx DocBook to markdown 1pandoc -f docbook -t markdown -s howto.xml -o example31.text MediaWiki to html5 1pandoc -f mediawiki -t html5 -s haskell.wiki -o example32.html Chunked HTML 1pandoc -t chunkedhtml --split-level=2 --toc --toc-depth=2 --number-sections -o example33 MANUAL.txt Docx with a reference docx 1pandoc --reference-doc twocolumns.docx -o UsersGuide.docx MANUAL.txt Docx to markdown, including math 1pandoc -s example30.docx -t markdown -o example35.md EPUB to plain text 1pandoc MANUAL.epub -t plain -o example36.text Using a template to produce a table from structured data 1pandoc fishwatch.yaml -t rst --template fishtable.rst -o fish.rst # see also the partial species.rst Converting a bibliography from BibTeX to CSL JSON 1pandoc biblio.bib -t csljson -o biblio2.json Producing a formatted version of a bibliography 1pandoc biblio.bib --citeproc --csl ieee.csl -s -o biblio.html 3 中文乱码问题 中文乱码问题，大多与字体有关，解决方案详见文章 Linux 系统字体安装https://tankenqi.cn/posts/2de821dc/","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"https://binwenwu.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/tags/Linux/"},{"name":"Pandoc","slug":"Pandoc","permalink":"https://binwenwu.github.io/tags/Pandoc/"}]},{"title":"K8S集群环境搭建(Containerd作为容器)","slug":"K8S集群环境搭建(Containerd作为容器)","date":"2023-08-06T07:08:12.000Z","updated":"2025-05-17T05:51:06.588Z","comments":true,"path":"posts/9d39de82/","link":"","permalink":"https://binwenwu.github.io/posts/9d39de82/","excerpt":"","text":"1 前述 1.1 云原生定义 Pivotal《传统应用和SOA向云原生转型指南》（2015）的云原生的特征： 符合 12 要素应用 基准代码：一份基准代码，多份部署（类似于Git版本控制系统的main分支）； 显示声明所有依赖关系：通过依赖清单，确切地声明所有依赖项； 把后端服务当作附加资源：各种后端服务（如数据库、消息队列、邮件服务、缓存系统），不区别对待本地或第三方服务； 构建、发布、运行：严格区分构建、发布、运行这三个步骤； 无状态进程：应用的进程必须无状态； 端口绑定：互联网应用通过端口绑定来提供服务，并监听发送至该端口的请求。应用完全自我加载，不依赖于任何网络服务器； 并发：通过进程模型进行扩展。进程是一等公民； 易处理：进程可以瞬间开启或停止，有利于快速、弹性的伸缩应用。进程应追求最小启动时间；进程一旦接受终止信号就会优化的终止；进程在面对突然死亡时保持健壮； 开发环境与线上环境等价：尽可能的保持开发，预发布，线上环境相同，以尽量做到持续部署； 日志：应用本身从不存储自己的输出流，不应该试图去写或者管理日志文件，相反，每一个运行的进程都会直接的标准输出（stdout）事件流； 管理进程：后台管理任务当作一次性进程运行； 面向微服务架构 微服务将单体系统分解为多个“仅做好一件事”的可独立部署的服务。这件事通常代表某项业务能力，或者最小可提供业务价值的“原子“服务单元。具备以下优点： 变更周期解耦：只要变更限于单一有界的环境，并且服务继续履行其现有合约；实现了更频繁和快速的部署，从而实现了持续的价值流动； 减少业务领域和现有代码的学习负担； 可以加快采用新技术的步伐； 提供独立、高效的服务扩展； 自服务敏捷架构（可以认为是DevOps）： 一个能够持续部署和运行这些微服务的平台；如代码以Git形式“推送”。 然后，自服务敏捷平台构建应用程序工件，构建应用程序环境，部署应用程序，并启动必要的进程。 团队不必考虑他们的代码在哪里运行或如何到达那里，这些对用户都是透明得，因为平台会关注这些。 基于 API 的协作 抗脆弱性 云原生计算基金会（2015）定义的特征 应用容器化 面向微服务架构 应用支持容器的编排制度 云原生计算基金会（2018）定义 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API 这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更 1.2 容器、虚拟机、Docker、Openstack 和 K8S 容器&amp;虚拟机：均为虚拟化技术，容器更为轻量化、效率更高、启动更快；虚拟机需数分钟启动，容器仅需数十毫秒； Docker： 容器化虚拟技术事实上的标准； OpenStack：分布式的虚拟机服务平台，相比于普通的虚拟机软件（如Vmare），多了分布式虚拟机调度管理的功能和节点的负载均衡； K8S：分布式的容器调度管理平台，相比于Docker，多了分布式的容器调度管理和节点的负载均衡； 注意：常见的中文资料均言K8S是容器编排软件，这里的编排是指调度、管理的意思，而非工作流编排的意思，容易有误导性； 注意：无论是Openstack还是K8S，均不支持跨节点的容器或虚拟机的创建；所以将多台电脑合并成一台电脑的想法是不现实的； 1.3 K8S 和 云原生 在单机上运行容器，无法发挥它的最大效能，只有形成集群，才能最大程度发挥容器的良好隔离、资源分配与编排管理的优势，而对于容器的编排管理，Swarm、Mesos 和 Kubernetes 的大战已经基本宣告结束，Kubernetes 成为了无可争议的赢家。 Kubernetes 成为云原生应用的基石 有机会成为跨云的真正的云原生应用的操作系统 1.4 K8S 介绍 官方：Kubernetes 也称为 K8S，是用于自动部署、扩缩和管理容器化应用程序的开源系统。 发展历史：由Google设计并捐赠给Cloud Native Computing Foundation（今属Linux基金会）来使用。 能力：Google 每周运行数十亿个容器，能够在不扩张运维团队的情况下进行规模扩展。 作用： 相当于一个操作系统，可以快速提供PaaS服务：1）创建各种容器化测试化环境；2）发布各种容器化服务；3）快速安装各种容器化服务，如MongoDB、Hbase、Postgresql、Redis、Spark等；快速提供IaaS服务：通过安装Openstack或KubeVirt等软件；快速提供FaaS服务：通过安装Kube Native等软件； 1.5 基本概念 Container：轻量级的系统虚拟化技术，使用namespace隔离环境。 Pod： K8S 的调度的基本单位，Pod是一组紧密关联的容器集合，内部的容器共享PID、IPC、Network和UTS namespace。可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。 ​ Pod的设计理念基础是微服务，不同类型的业务组合由不同类型的Pod执行，一个Pod对应一个微服务 K8S中，采用manifest（yaml或json）定义对象，比如nginx服务（包含了一个nginx 容器image）定义为： 1234567891011apiVersion: v1kind: Podmetadata: name: nginx labels: app: nginxspec: containers: - name: nginx image: nginx ports: Node: 是Pod运行的主机，可以为物理机，也可以为虚拟机。每个Node上要运行container runtime （docker或者rkt）、kubelet和kube-proxy服务 Service: 一个Pod只是一个运行服务的实例，可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod。在K8S集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。 Kubelet: 每个Node的任务和资源管理 Kube-proxy: 负责每个节点的硬件负载均衡 1.6 K8S 常见命令 运行一个Nginix容器： kubectl run --image=nginx:alpine nginx-app --port=80 Kubectl 命令： kubectl get - 类似于 docker ps，查询资源列表 kubectl describe - 类似于 docker inspect，获取资源的详细信息 kubectl logs - 类似于 docker logs，获取容器的日志 kubectl exec - 类似于 docker exec，在容器内执行一个命令 kubectl create -f file.yaml – 根据yaml创建Deployment资源 kubectl delete 删除命令，可删除node、pod、svc、depolyment yaml 定义 Pod： 123456789101112apiVersion: v1kind: Podmetadata: name: nginx labels: app: nginxspec: containers: - name: nginx image: nginx ports: - containerPort: 80 Volume： 一个Pod一旦发生异常，Pod 产生的数据会随着 Pod 消亡而自动消失。Volume 用于持久化容器数据。 如：为 redis 容器指定一个 hostPath 来存储 redis 数据 123456789101112131415apiVersion: v1kind: Podmetadata: name: redisspec: containers: - name: redis image: redis volumeMounts: - name: redis-persistent-storage mountPath: /data/redis volumes: - name: redis-persistent-storage hostPath: path: /data/ Service： kubectl创建Pod，Pob的IP地址会随着Pod的重启而变化 为了访问Pod提供的服务，采用Service提供为一组Pod一个统一的入口，并提供负载均衡和自动服务发现。 kubectl expose deployment nginx-app --port=80 --target-port=80 --type=NodePort Replicas set： 在一个Service中,可为Pod设置数个副本，以确保服务永不掉线 kubectl scale --replicas=3 deployment/nginx-app 滚动升级（Rolling Update）： 滚动升级（Rolling Update）通过逐个副本容器替代升级的方式来实现无中断的服务升级： kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2 滚动升级中若发生错误，可随时回滚： kubectl rolling-update frontend-v1 frontend-v2 --rollback 资源限制： K8S通过 cgroups 提供容器资源管理的功能，可限制每个容器的 CPU 和内存使用，比如对于刚才创建的 deployment，可以通过下面的命令限制 nginx 容器最多只用 50% 的 CPU 和 128MB 的内存： kubectl set resources deployment nginx-app -c=nginx --limits=cpu=500m,memory=128Mi 或者在yaml中指定资源限制 健康检查： K8S Kubernetes 提供了两种探针（Probe，支持 exec、tcpSocket 和 http 方式）来探测容器的状态： LivenessProbe：探测应用是否处于健康状态，如果不健康则删除并重新创建容器 ReadinessProbe：探测应用是否启动完成并且处于正常服务状态，如果不正常则不会接收来自 Kubernetes Service 的流量 1.7 K8S 常用运维命令 查看pod，及所在的节点： kubectl get pods -o wide 若有节点warn，回收垃圾失败： 12kubectl drain --delete-local-data --ignore-daemonsets NODENAMEkubectl uncordon NODENAME 2 K8S 集群基础环境部署 若服务器之前搭建过 K8S 集群，需要彻底删除 参考：https://blog.csdn.net/qq_43159578/article/details/124131709 停止所有的Kubernetes服务 12sudo systemctl stop kubeletsudo systemctl stop containerd 删除Kubernetes软件包 1yum remove kubeadm kubectl kubelet kubernetes-cni -y 删除配置文件 1234# 清除残留文件rm -rf /root/.kuberm -rf /etc/cni/net.drm -rf /etc/kubernetes/* 删除etcd数据目录 1rm -rf /var/lib/etcd 清除iptables或者ipvs的配置 12# sudo ipvsadm -C# sudo iptables -F &amp;&amp; sudo iptables -t nat -F &amp;&amp; sudo iptables -t mangle -F &amp;&amp; sudo # # iptables -Xkubec 如果只是想重新部署集群 1kubeadm reset kubeadm reset 命令用于清除当前节点上所有与 kubeadm init 或 kubeadm join 命令创建的 Kubernetes 集群相关的状态。其主要作用如下： 移除 Kubernetes 集群相关的系统服务，如 kubelet 和 kube-proxy。 删除所有在当前节点上创建的 Kubernetes 对象，包括 Pod、Service、Deployment 等。 移除 etcd 中与当前节点相关的信息，如节点标识、配置信息等。 删除 Kubernetes 数据目录，包括证书、密钥、kubeconfig 文件等。 使用 kubeadm reset 命令可以清除当前节点上的所有 Kubernetes 相关状态，以便重新创建新的 Kubernetes 集群或者将当前节点加入到另一个 Kubernetes 集群中。在进行 kubeadm reset 操作之前，应该先备份当前节点上的重要数据和配置信息，以便在需要时进行恢复。 2.1 服务器 网络资源：各节点间通过千兆交换机互联（非光纤交换机） 管理节点： Gisweb4，Gisweb3 计算节点： Gisweb3，GISweb2，dellm640-01, Gisweb4, dellslot03, dellslot4 持久化存储资源： 目前采用： nfs-client: 23服务器的/mnt/storage/k8s/pv Node1（刀片3）： 子网 IP：192.168.0.177 CPU：Intel® Xeon® Silver 4216 CPU @ 2.10GHz；32核心，64线程。 内存：64GB（32GB*2），每根DDR4，3000Mhz Node2（刀片4）： 子网 IP：192.168.0.209 CPU：Intel® Xeon® Silver 4216 CPU @ 2.10GHz；32核心，64线程。 内存：64GB（32GB*2），每根DDR43200Mhz 2.2 安装过程 2.2.1 前提条件 a. 节点之中不可以有重复的主机名、MAC 地址或 product_uuid 1cat /sys/class/dmi/id/product_uuid b. 检查网络适配器：若有多个网卡，确保每个node的子网通过默认路由可达 c. 防火墙开放端口(所有节点)： 1234567systemctl restart firewalldfirewall-cmd --zone=public --add-port=443/tcp --permanentfirewall-cmd --zone=public --add-port=6443/tcp --permanentfirewall-cmd --zone=public --add-port=2379-2380/tcp --permanentfirewall-cmd --zone=public --add-port=10250/tcp --permanentfirewall-cmd --zone=public --add-port=10259/tcp --permanentfirewall-cmd --zone=public --add-port=10257/tcp --permanent d. 关闭防火墙(所有节点）： 12systemctl stop firewalld NetworkManagersystemctl disable firewalld NetworkManager e. 关闭交换分区并禁用 SELinux（所有节点）： 1234567891011121314151617181920212223# 查看 交换分区free -m# 将 `SELinux` 设置为 `permissive` 模式（相当于将其禁用） 第一行是临时禁用，第二行是永久禁用setenforce 0sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config# 关闭swap；第一行是临时禁用，第二行是永久禁用swapoff -a sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab# 允许 iptables 检查桥接流量 （K8s 官方要求）cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confbr_netfilterEOFcat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 让配置生效sysctl --system f. 时间同步（所有节点）： 1234yum install chrony -ysystemctl start chronydsystemctl enable chronydchronyc sources g. 设置主机名并添加 ip 映射（所有节点）： 123456789101112131415161718192021222324252627# 以 gisweb4 为例# 查看主机名cat hostname# 设置主机名hostnamectl set-hostname gisweb4# 更新bash# 添加 ip 映射echo &quot;125.250.153.23 gisweb4&quot; &gt;&gt; /etc/hostsecho &quot;125.250.153.23 gisweb4&quot; &gt;&gt; /etc/hosts# 两台无外网ip的刀片添加内网ip# /etc/hosts 文件内容如下：192.168.0.203 gisweb1192.168.0.202 gisweb2192.168.0.204 gisweb4192.168.0.208 gisweb3192.168.0.176 dellm640-01192.168.0.177 dellm640-03192.168.0.209 dellslot04125.220.153.26 gisweb1125.220.153.25 gisweb2125.220.153.22 gisweb3125.220.153.23 gisweb4125.220.153.28 dellm640-01 2.2.2 升级 Linux 内核到最新（所有节点）： 清除缓存，重新构建缓存： 12# 清除缓存yum makecache &amp; yum -y update 参考链接：https://zhuanlan.zhihu.com/p/368879345 2.2.3 转发 IPv4 并让 iptables 看到桥接流量（所有节点） 12345678910111213141516171819202122# a. 验证br_netfilter是否已经加载lsmod | grep br_netfilter# b. 加载br_netfilter模块：modprobe br_netfilter# c. iptabels桥接cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confoverlaybr_netfilterEOFmodprobe overlaymodprobe br_netfilter# 设置所需的 sysctl 参数，参数在重新启动后保持不变cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1net.ipv4.ip_forward = 1EOF# 应用 sysctl 参数而不重新启动sysctl --system 2.2.4 安装 ipvsadm（所有节点） 1234567891011121314151617181920yum install ipvsadm ipset sysstat conntrack libseccomp -ycat &lt;&lt;EOF | sudo tee /etc/modules-load.d/ipvs.confip_vsip_vs_rrip_vs_wrrip_vs_shnf_conntrackip_tablesip_setxt_setipt_setipt_rpfilteript_REJECTipipEOFsystemctl restart systemd-modules-load.servicelsmod | grep -e ip_vs -e nf_conntrack 2.2.5 修改内核参数（所有节点，lb除外） 1234567891011121314151617181920212223242526272829303132cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.ipv4.ip_forward = 1net.bridge.bridge-nf-call-iptables = 1fs.may_detach_mounts = 1vm.overcommit_memory=1vm.panic_on_oom=0fs.inotify.max_user_watches=89100fs.file-max=52706963fs.nr_open=52706963net.netfilter.nf_conntrack_max=2310720net.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl =15net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_max_orphans = 327680net.ipv4.tcp_orphan_retries = 3net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.ip_conntrack_max = 65536net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.tcp_timestamps = 0net.core.somaxconn = 16384net.ipv6.conf.all.disable_ipv6 = 0net.ipv6.conf.default.disable_ipv6 = 0net.ipv6.conf.lo.disable_ipv6 = 0net.ipv6.conf.all.forwarding = 1EOFsysctl --systemS 2.2.6 安装Container Runtime(选用containerd,弃用docker)： Docker-engine+cir-dockerd方案（舍弃）：从kubernetes 1.24开始，dockershim已经从kubelet中移除，但因为历史问题docker却不支持kubernetes主推的CRI（容器运行时接口）标准，需要在kubelet和docker之间加上一个中间层cri-docker。cri-docker是一个支持CRI标准的shim。一头通过CRI跟kubelet交互，另一头跟docker api交互，从而间接的实现了kubernetes以docker作为容器运行时。但是这种架构缺点也很明显，调用链更长，效率更低。因此选用containerd作为容器runtime containerd方案: containerd是一个docker的容器runtime，成为CNCF的官方项目 官方安装教程：https://github.com/containerd/containerd/blob/main/docs/getting-started.md 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 安装containerd.ioyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum install containerd.io# 安装CNI插件# i.下载cni-plugins.tar 从https://github.com/containernetworking/plugins/releases# 在线下载：# wget https://github.com/containernetworking/plugins/releases/download/v1.1.1/cni-plugins-linux-amd64-v1.1.1.tgz# ii.在/opt/cni/bin下解压：# 把22上的拷贝到没有公网ip的服务器上# scp -P22 /opt/cni/bin/cni-plugins-linux-amd64-v1.1.1.tgz root@192.168.0.203:/opt/cni/bin/mkdir -p /opt/cni/bincd /opt/cni/bintar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz# 重启服务：systemctl restart containerd# 开机启动：systemctl enable containerd# 配置systemd cgroup驱动# 修改配置文件，将 SystemdCgroup 改为 true 注意配置项是区分大小写的containerd config default | sudo tee /etc/containerd/config.tomlvim /etc/containerd/config.toml[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc] ... [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options] SystemdCgroup = true# 并将 sandbox_image 地址修改为国内的地址并且将 sandbox_image = &quot;registry.k8s.io/pause:3.6&quot;修改为 sandbox_image = &quot;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6&quot;# 启动 containerdsystemctl restart containerd# 开机自启systemctl enable containerd# 启动成功后可以查看到监听的端口netstat -nlput | grep containerdtcp 0 0 127.0.0.1:36669 0.0.0.0:* LISTEN 8665/containerd off (0.00/0/0) 2.2.7 在所有电脑上安装 kubeadm, kubelet and kubectl（所有节点） 123# a. kubeadm: the command to bootstrap the cluster.# b. kubelet: the component that runs on all of the machines in your cluster and does things like starting pods and containers.# c. kubectl: the command line util to talk to your cluster. 配置阿里云的k8s源，加速安装 123456789cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 将 SELinux 设置为 permissive 模式（相当于将其禁用） 12setenforce 0sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config 安装 1234yum install -y --nogpgcheck kubelet-1.25.2 kubeadm-1.25.2 kubectl-1.25.2 # sudo yum install -y --nogpgcheck kubelet-1.26.3 kubeadm-1.26.3 kubectl-1.26.3 # 自启动systemctl enable --now kubelet 2.2.8 启动控制面节点 123kubeadm init --kubernetes-version=v1.25.2 --image-repository registry.aliyuncs.com/google_containers --pod-network-cidr=10.244.0.0/16 #kubeadm init --kubernetes-version=v1.26.3 --image-repository registry.aliyuncs.com/google_containers --pod-network-cidr=10.244.0.0/16 若出现如下错误（上一次集群初始化的残留文件） 12# 如果出现报错 [ERROR FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml]: /etc/kubernetes/manifests/kube-apiserver.yaml already exists 执行如下命令后再次初始化 12rm -rf /var/lib/etcdrm -rf /etc/kubernetes/manifests/* 2.2.9 配置环境变量(初始化后) 123mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config 2.2.10 将 master 作为node（管理节点上执行） 检查 node 是否存在污点 污点值有三种： NoSchedule：一定不被调度 PreferNoSchedule：尽量不被调度【也有被调度的几率】 NoExecute：不会调度，并且还会驱逐Node已有Pod 1kubectl describe nodes gisweb4 |grep Taints 删除污点： 12# 本次删除的污点为：node-role.kubernetes.io/control-plane-kubectl taint nodes --all node-role.kubernetes.io/control-plane- 2.2.11 安装 Pod 网络插件（CNI：Container Network Interface）(master) 你必须部署一个基于 Pod 网络插件的 容器网络接口 (CNI)，以便你的 Pod 可以相互通信。 确保kubeadm初始化时，pod_cidr 为10.244.0.0 下载 yml 配置文件 或自己下载到本地 1curl https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml -O 编辑kube-flannel.yml 找到如下位置，添加 iface-regex 123vim kube-flannel.yml# 添加- --iface-regex=^192.168.. 构建 1kubectl apply -f kube-flannel.yml 2.2.12 node 节点加入集群 管理节点获取加入命令： 123kubeadm token create --print-join-command# 返回如下kubeadm join 125.220.153.23:6443 --token x0wdaj.d5wltdzdtos22fl6 --discovery-token-ca-cert-hash sha256:9245d363cdeb1757bacba21b9ccdc06a28e7490bcedfb0eeb404b56f769fa112 在 node 节点执行生成命令 如果此步报如下错误 The connection to the server localhost:8080 was refused - did you specify the right host 出现这个问题的原因是kubectl命令需要使用kubernetes-admin的身份来运行，在kubeadm int启动集群的步骤中就生成了/etc/kubernetes/admin.conf。 因此，解决方法如下，将主节点中的/etc/kubernetes/admin.conf文件拷贝到工作节点相同目录下： 然后分别在工作节点上配置环境变量： 解决方案 主节点执行 12# 将主节点中的【/etc/kubernetes/admin.conf】文件拷贝到工作节点相同目录下：scp -P22 /etc/kubernetes/admin.conf oge@125.220.153.22:/etc/kubernetes/ node 节点执行如下命令后，再次执行加入集群的命令 12echo &quot;export KUBECONFIG=/etc/kubernetes/admin.conf&quot; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 如果是重新加入集群，需要 reset 一下 1kubeadm reset 2.2.13 添加新的 master 节点 管理节点： 123456789101112131415# 管理节点查看kubeadm token create --print-join-command# 生成如下kubeadm join 125.220.153.23:6443 --token mc56rw.t9b3d1ql53yhom9y --discovery-token-ca-cert-hash sha256:753ccf865a9c590413043d469a9848300871afaef7221e3fdb97d981939a2b83# 管理节点kubeadm init phase upload-certs --upload-certs # 输出I0413 11:00:30.817038 10009 version.go:256] remote version is much newer: v1.27.0; falling back to: stable-1.25[upload-certs] Storing the certificates in Secret &quot;kubeadm-certs&quot; in the &quot;kube-system&quot; Namespace[upload-certs] Using certificate key:70d43cde7f6423b5c3e88c0fa9d08511cefbc53992dc63a13544cd548a912941# 管理节点，在networking前添加：controlPlaneEndpoint: 125.220.153.23:6443kubectl -n kube-system edit cm kubeadm-config 新的master节点 1234567891011121314151617181920# 新节点# 重新加入的话，检查是否需要kill掉6443端口（这是之前的api-service服务）kubeadm join 125.220.153.23:6443 --token mc56rw.t9b3d1ql53yhom9y --discovery-token-ca-cert-hash sha256:753ccf865a9c590413043d469a9848300871afaef7221e3fdb97d981939a2b83 --control-plane --certificate-key 70d43cde7f6423b5c3e88c0fa9d08511cefbc53992dc63a13544cd548a912941# 生成This node has joined the cluster and a new control plane instance was created:* Certificate signing request was sent to apiserver and approval was received.* The Kubelet was informed of the new secure connection details.* Control plane label and taint were applied to the new node.* The Kubernetes control plane instances scaled up.* A new etcd member was added to the local/stacked etcd cluster.To start administering your cluster from this node, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configRun &#x27;kubectl get nodes&#x27; to see this node join the cluster. 3 K8S 管理平台 dashboard 环境部署（管理节点） 下载 yaml 配置文件并应用 或下载到本地然后上传 1kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml 修改配置文件(以node) 但是这个只能内部访问，所以要外部访问，要么部署 ingress，要么就是设置 service NodePort 类型。这里选择 service 暴露端口。 1234567kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard# 将其中的，type: ClusterIP 修改成type: NodePort，保存退出即可。# 查看服务的暴露端口，需在安全组放行kubectl get svc -A |grep kubernetes-dashboard 权限认证 123456# 创建访问用户kubectl apply -f https://kuboard.cn/install-script/k8s-dashboard/auth.yaml# 获取访问令牌kubectl -n kubernetes-dashboard create token admin-user # 生成的令牌eyJhbGciOiJSUzI1NiIsImtpZCI6IkdVQTZzb3JEM1FHdkpxVDNsSEwtVEZWc2hyR08tbmFFWnFGX2Q2OGt5cEkifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjgzNzM1MTQ1LCJpYXQiOjE2ODM3MzE1NDUsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiMzBlMWQzNDEtNDc0Yi00M2MyLWIyNzYtZGIxZTU4NzM5ZTgxIn19LCJuYmYiOjE2ODM3MzE1NDUsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.mg1IU29tBpH23nglJVbRmVa2A26WZjXxMCzckQyb-dnviLBRzBuvNebb8H4YH5CNJUPkB2GGC_r7dlm5zEbPpK8RqkbwXy-wqkOoMephs83gIQkJ3RgskpWqTgqqg87e6WXHRtuzYsQQZ4Rq3Y4uQy9jJS9o1lIoRTujpmpWORb9vu4JN0RqEfK2chQqNsYCe_TCtvtvkP2EyuU3QSeYdvWh5NNZ9CYwA8l8eqA6ijrmTqZjnI6Q9Ymo7trKSuGFmffotBpN9dTYZoyv6Io_VgEz6_1oHsA0pwG-3wc41Ly11sDAzwjZvoGN1yfw0vsVcwnAjH4LkRG2ImwYIcZbig 访问方式（每个节点 ip 均可访问）：https://125.220.153.23:30151 4 安装K8S的包管理工具Helm （管理节点） 参考：https://helm.sh/docs/intro/install/ 这里以下载压缩包安装为例： 参考：https://www.cnblogs.com/zhanglianghhh/p/14165995.html github地址：https://github.com/helm/helm 123456cd ~/k8s/helmwget https://get.helm.sh/helm-v3.11.3-linux-amd64.tar.gztar zxfv helm-v3.11.3-linux-amd64.tar.gzmv ./linux-amd64/helm /usr/bin/# 显示版本，安装完成helm version 5 安装K8S的包管理工具 krew（管理节点） 参考：https://krew.sigs.k8s.io/docs/user-guide/setup/install/ 确保 git 已经安装 123git version# 若未安装yum -y install git 安装krew 123456789( set -x; cd &quot;$(mktemp -d)&quot; &amp;&amp; OS=&quot;$(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)&quot; &amp;&amp; ARCH=&quot;$(uname -m | sed -e &#x27;s/x86_64/amd64/&#x27; -e &#x27;s/\\(arm\\)\\(64\\)\\?.*/\\1\\2/&#x27; -e &#x27;s/aarch64$/arm64/&#x27;)&quot; &amp;&amp; KREW=&quot;krew-$&#123;OS&#125;_$&#123;ARCH&#125;&quot; &amp;&amp; curl -fsSLO &quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/$&#123;KREW&#125;.tar.gz&quot; &amp;&amp; tar zxvf &quot;$&#123;KREW&#125;.tar.gz&quot; &amp;&amp; ./&quot;$&#123;KREW&#125;&quot; install krew) 添加 $HOME/.krew/bin目录到您的 PATH 环境变量。 更新你的 .bashrc或者 .zshrc文件 123# 永久写的用户的环境变量文件，避免登出后失效export PATH=&quot;$&#123;KREW_ROOT:-$HOME/.krew&#125;/bin:$PATH&quot;source ~/.bashrc 若安装失败，采用压缩包安装 12345678910wget https://github.com/kubernetes-sigs/krew/releases/latest/download/krew-linux_amd64.tar.gztar -zxvf krew-linux_amd64.tar.gz# 添加$HOME/.krew/bin目录到PATH环境变量export PATH=&quot;$&#123;KREW_ROOT:-$HOME/.krew&#125;/bin:$PATH&quot;# 配置为 kubectl 插件mv ./krew-linux_amd64 ./kubectl-krewmv ./kubectl-krew /usr/local/bin/# 测试kubectl krew version 检查是否安装成功 12kubectl krewkubectl plugin list 6 为 K8S 创建 PV 持久卷 6.1 PV和PVC 持久卷(PersistentVolume，PV)是集群中由管理员配置的一段网络存储。它是集群中的资源，就像节点是集群资源一样。PV持久卷和普通的Volume一样，也是使用卷插件来实现的，只是它们拥有独立于任何使用PV的Pod的生命周期。此API对象捕获存储实现的详细信息，包括NFS，iSCSI或特定于云提供程序的存储系统。 持久卷申领(PersistentVolumeClaim，PVC)表达的是用户对存储的请求。概念上与Pod类似。Pod会耗用节点资源，而PVC申领会耗用PV资源。 6.2 用 storageClass 动态创建 PV 对1PB的大量目录创建NFS服务，gisweb1-4，以gisweb4为例子 12安装NFS: yum -y install nfs-utils rpcbind 设置持久卷权限 123# 执行权限chown -R nobody:nfsnobody /mnt/storage/k8s/pv#chmod -R 777 /mnt/storage/k8s/pv 配置 nfs 1234vim /etc/exports# 添加：/mnt/storage/k8s/pv 192.168.0.0/24(rw,sync,no_root_squash)# 以上设置让所有的 IP 都有效 1234567891011systemctl start rpcbindsystemctl enable rpcbindsystemctl enable nfssystemctl start nfssystemctl start nfs-serversystemctl enable nfs-serversystemctl start firewalldfirewall-cmd --permanent --add-service=nfsfirewall-cmd --reloadsystemctl stop firewalld &amp;&amp; sudo systemctl disable firewalld 检查 12exportfs -rvshowmount -e 127.0.0.1 所有节点安装nfs客户端 12345yum install -y nfs-utils# 每个节点挂载nfs客户端的存储目录，本次nfs客户端在gisweb4（192.168.0.204）上mount -t nfs 192.168.0.204:/mnt/storage/k8s/pv /mnt/storage/k8s/pv # 检查挂载情况df -h 安装nfs-client-provisioner (需要翻墙) 参考：https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner 12345678910111213# 更新helm repohelm repo update# 搜索helm库中nfs版本helm search repo nfs-subdir-external-provisioner# 添加 helm 仓库helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \\--set nfs.server=192.168.0.204 \\--set nfs.path=/mnt/storage/k8s/pv \\--set image.repository=registry.cn-hangzhou.aliyuncs.com/xzjs/nfs-subdir-external-provisioner \\--set image.tag=v4.0.0 手动安装 nfs-client-provisioner 参考：http://www.mydlq.club/article/109/#创建-nfs-subdir-external-provisioner-部署文件 成功后，安装时添加持久化参数，其中 nfs-storage 为安装的 storageclass 的 provisioner 字段名字 7 安装 kubeAPPS 可视化软件管理工具 参考：https://kubeapps.dev/docs/latest/tutorials/getting-started/ 安装 123456# 添加 kubeapps 仓库helm repo add bitnami https://charts.bitnami.com/bitnami# 创建 kubeapps 的命名空间kubectl create namespace kubeapps# 安装helm install kubeapps --namespace kubeapps bitnami/kubeapps 创建证书 123456789101112131415# 创建用于访问 Kubeapps 和 Kubernetes 的演示凭证kubectl create --namespace default serviceaccount kubeapps-operatorkubectl create clusterrolebinding kubeapps-operator --clusterrole=cluster-admin --serviceaccount=default:kubeapps-operatorcat &lt;&lt;EOF | kubectl apply -f -apiVersion: v1kind: Secretmetadata: name: kubeapps-operator-token namespace: default annotations: kubernetes.io/service-account.name: kubeapps-operatortype: kubernetes.io/service-account-tokenEOF 查看令牌 token 1kubectl get --namespace default secret kubeapps-operator-token -o go-template=&#x27;&#123;&#123;.data.token | base64decode&#125;&#125;&#x27; 1eyJhbGciOiJSUzI1NiIsImtpZCI6IkdVQTZzb3JEM1FHdkpxVDNsSEwtVEZWc2hyR08tbmFFWnFGX2Q2OGt5cEkifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6Imt1YmVhcHBzLW9wZXJhdG9yLXRva2VuIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6Imt1YmVhcHBzLW9wZXJhdG9yIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiNTNjY2M0N2YtZWFmMS00NDY4LWJkN2ItYTVhMzliMzJjMzExIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlZmF1bHQ6a3ViZWFwcHMtb3BlcmF0b3IifQ.qsTBQODZLD1EUP5WjF_ju0-_ZFoJa2pEGCGf2zoLK71TjZeytD0GUGp4Z5ACNFuJMtedtx8tRgWhioU2oimxGdCIL4f7Szt0dOQgXD15HmoiUjYEcDQNsfTdcmfZw-m3-zwtTqa3kTTG3Wio0wf_f_ayw8qZCDL2i3PK-7h0QeAb1rQhtCz_e8huNrcshjixGlyw8aKUvdi2hPe6yvpxKJqQeOalNhT22b-ax28oIyqmC-NXYUMyRbEsgOjyuJAv6XdjqsQKbOGMKsTtNyf7CvnHl88hfRZpF0W-GuKj1ggKGYClTHuXnsv9QP-AQN1UaEtcAbUp08bHN9isedJL6w 修改服务模式，将其改为 NodePort 12# 因为是测试环境，因此直接采用 NodePort 方式暴露服务端口kubectl edit svc kubeapps -n kubeapps 找到端口，在安全组放行 1kubectl get svc -A |grep kubeapps 访问：http://125.220.153.23:31885/ 8 在 K8S 上部署虚拟机服务 Kubevirt 设置 K8S ApiServer 允许特权容器 123vim /etc/kubernetes/manifests/kube-apiserver.yaml# 设置 --allow-privileged=true 检查每个节点是否支持虚拟化 123virt-host-validate qemu# 如果显示没有这个命令，先安装 libvrt 和 qemu 软件包：yum install -y qemu-kvm libvirt virt-install bridge-utils 若有warnning，需要解决 12345678# 1vim /etc/default/grub# 2.添加GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet intel_iommu=on&quot;# 3 grub2-mkconfig -o /boot/grub2/grub.cfg# 4 reboot 安装 Kubevirt 1234# K8S 1.25版本，Kubervirt必须0.57.2以上，才能适配kubectl apply -f https://github.com/kubevirt/kubevirt/releases/download/v0.58.0-rc.0/kubevirt-operator.yamlkubectl apply -f https://github.com/kubevirt/kubevirt/releases/download/v0.58.0-rc.0/kubevirt-cr.yaml 等待 Kubevirt 资源创建完毕 1kubectl -n kubevirt wait kv kubevirt --for condition=Available 安装 CDI 参考：https://kubevirt.io/labs/kubernetes/lab2.html 安装 VNC 1yum install -y tigervnc 查看 Kubevirt 资源 1kubectl get pods -n kubevirt 安装 Kubevirt 的 cli 管理工具 12kubectl krew install virtkubectl virt help Kubevirt创建/删除虚拟机服务 123456789101112# 1. 创建yaml文件Xxx# 2. 运行一个虚拟机kubectl apply -f test.yaml# 3. 查看虚拟机kubectl get vmis# 4. 停止/删除虚拟机kubectl delete -f vmi.yaml# 或者kubectl delete vmis testvmi# 5. 开始/停止/暂停虚拟机virtctl start/stop/pause my-vm 9 在 K8S 上部署 PostgreSQL 安装 注意：数据库安装需要持久卷，需提前创建满足要求的pv，或者创建nas的stroageclass，以自动根据mysql的pvc创建pv。 集群已经配置23服务器的/mnt/storage/k8s/pv为NAS,并已经配置名字为nas-storage的sc 12345678910111213141516171819202122helm repo add bitnami https://charts.bitnami.com/bitnami# 首先检查是否有oge这个命名空间，否则执行如下进行创建kubectl create ns oge# postgresql 这个名字可以自己定义，但后面每一步都要注意对应更改helm install -n oge bitnami/postgresql \\--set global.storageClass=nfs-client \\--set readReplicas.persistence.storageClass=nfs-client \\--set primary.persistence.storageClass=nfs-client \\--set primary.persistence.size=200Gi \\--set readReplicas.persistence.size=200Gi \\--set image.tag=14.5.0-debian-11-r6helm install -n geoctap bitnami/postgresql \\--set global.storageClass=nfs-client \\--set readReplicas.persistence.storageClass=nfs-client \\--set primary.persistence.storageClass=nfs-client \\--set primary.persistence.size=200Gi \\--set readReplicas.persistence.size=200Gi \\--set image.tag=14.5.0-debian-11-r6# 指定版本，可在kubeapps里面查看# --set image.tag=14.5.0-debian-11-r6 查看 postgresql 密码 1234kubectl get secret --namespace oge postgresql -o jsonpath=&quot;&#123;.data.postgres-password&#125;&quot; | base64 -d# 密码7jXf2gsmUX 更改服务端口 1234kubectl edit svc --namespace oge postgresql# 将 type=ClusterIP 改为 NodePort# b8:85:84:71:64:28echo &quot;SUBSYSTEM==\\&quot;net\\&quot;, ACTION==\\&quot;add\\&quot;, DRIVERS==\\&quot;?*\\&quot;, ATTR&#123;address&#125;==\\&quot; b8:85:84:71:64:28\\&quot;, ATTR&#123;type&#125;==\\&quot;1\\&quot;, KERNEL==\\&quot;eno*\\&quot;, NAME=\\&quot;eno1\\&quot;&quot; &gt;&gt; /etc/udev/rules.d/70-persistent-net.rules 缩放副本集 123456kubectl get deployment # 发现并没有postgresqlkubectl get all -n oge# 发现有statefulset.apps/postgresql# 设置副本集个数为1kubectl scale --replicas=1 statefulset.apps/postgresql -n oge 命令行进入pgsql 123456# 进入pgsql的podkubectl exec -it -n oge postgresql-0 bash # 用户登录psql -U postgres # 输入密码7jXf2gsmUX 在pod外面执行sql 1psql -h 125.220.153.23 -p 30865 -U postgres -W -f ./public.sql 10 在 K8S 上部署 MySQL 安装 注意：数据库安装需要持久卷，需提前创建满足要求的pv，或者创建nas的 stroageclass，以自动根据postgresql的pvc创建pv。 集群已经配置23服务器的/mnt/storage/k8s/pv为 NAS,并已经配置名字为 nas-storage 的 sc 123456789helm repo add bitnami https://charts.bitnami.com/bitnami# 安装helm install -n oge mysql bitnami/mysql \\--set global.storageClass=nfs-client \\--set readReplicas.persistence.storageClass=nfs-client \\--set primary.persistence.storageClass=nfs-client \\--set primary.persistence.size=200Gi \\--set readReplicas.persistence.size=200Gi 查看 MySQL 密码 1234kubectl get secret --namespace oge mysql -o jsonpath=&quot;&#123;.data.mysql-root-password&#125;&quot; | base64 -d# 密码VubCMiHvT1 更改服务端口 1234kubectl edit svc --namespace oge mysql# 将type=ClusterIP改为NodePort# b8:85:84:71:64:28echo &quot;SUBSYSTEM==\\&quot;net\\&quot;, ACTION==\\&quot;add\\&quot;, DRIVERS==\\&quot;?*\\&quot;, ATTR&#123;address&#125;==\\&quot; b8:85:84:71:64:28\\&quot;, ATTR&#123;type&#125;==\\&quot;1\\&quot;, KERNEL==\\&quot;eno*\\&quot;, NAME=\\&quot;eno1\\&quot;&quot; &gt;&gt; /etc/udev/rules.d/70-persistent-net.rules 缩放副本集 12345kubectl get deployment # 发现并没有mysqlkubectl get all -n oge# 发现有statefulset.apps/mysqlkubectl scale --replicas=1 statefulset.apps/mysql -n oge 在K8S中进入数据库 1234kubectl exec -it -n oge mysql-1 bash# 进入后登录用户mysql -u root -p# 输入密码 11 在K8S上部署 MongoDB 安装 注意：数据库安装需要持久卷，需提前创建满足要求的pv，或者创建nas的stroageclass，以自动根据postgresql的pvc创建pv。 集群已经配置23服务器的/mnt/storage/k8s/pv为NAS,并已经配置名字为nas-storage的sc 123456789helm repo add bitnami https://charts.bitnami.com/bitnami# 安装helm install -n ydy mongodb bitnami/mongodb \\--set global.storageClass=nfs-client \\--set readReplicas.persistence.storageClass=nfs-client \\--set primary.persistence.storageClass=nfs-client \\--set primary.persistence.size=100Gi \\--set readReplicas.persistence.size=100Gi 查看 MongoDB 密码 1234kubectl get secret --namespace ydy mongodb -o jsonpath=&quot;&#123;.data.mongodb-root-password&#125;&quot; | base64 -d# 密码WUL9FPQ2V9 更改服务端口 1234kubectl edit svc --namespace ydy mongodb# 将type=ClusterIP改为NodePort# b8:85:84:71:64:28echo &quot;SUBSYSTEM==\\&quot;net\\&quot;, ACTION==\\&quot;add\\&quot;, DRIVERS==\\&quot;?*\\&quot;, ATTR&#123;address&#125;==\\&quot; b8:85:84:71:64:28\\&quot;, ATTR&#123;type&#125;==\\&quot;1\\&quot;, KERNEL==\\&quot;eno*\\&quot;, NAME=\\&quot;eno1\\&quot;&quot; &gt;&gt; /etc/udev/rules.d/70-persistent-net.rules 缩放副本集 12345kubectl get deployment # 发现并没有mongodbkubectl get all -n ydy# 发现有statefulset.apps/mongodbkubectl scale --replicas=1 statefulset.apps/mongodb -n ydy 在K8S中进入数据库 1kubectl exec -it -n ydy mongodb-644c657c4f-x62cn bash 12 在 K8S 上部署 Apache Spark 两个方式，第一种方式为Spark官方提出的；第二种为Google提出的，更符合K8S原生概念 Spark On K8S spark-on-k8s-operator Spark On K8S spark-on-k8s-operator 12.1 安装 spark-on-k8s-operator 参考 ：https://blog.csdn.net/w8998036/article/details/122217230 安装 1234567helm repo add spark-operator https://googlecloudplatform.github.io/spark-on-k8s-operator # 注意是否存在 spark-operator 命名空间，没有则创建kubectl create ns spark-operator# 安装helm install spark-operator spark-operator/spark-operator --namespace spark-operator --set sparkJobNamespace=default --set webhook.enable=true 创建服务账户 12vim spark-application-rbac.yaml# 内容如下 1234567891011121314151617181920212223242526272829303132apiVersion: v1kind: ServiceAccountmetadata: name: spark namespace: spark---apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: spark name: spark-rolerules:- apiGroups: [&quot;&quot;] resources: [&quot;pods&quot;] verbs: [&quot;*&quot;]- apiGroups: [&quot;&quot;] resources: [&quot;services&quot;] verbs: [&quot;*&quot;]---apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: spark-role-binding namespace: sparksubjects:- kind: ServiceAccount name: spark namespace: sparkroleRef: kind: Role name: spark-role apiGroup: rbac.authorization.k8s.io 1kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --user=root 编写作业模板并提交作业 创建一个Spark作业的YAML配置文件，并进行部署。 创建spark-pi.yaml文件 1234567891011121314151617181920212223242526272829303132333435363738394041apiVersion: &quot;sparkoperator.k8s.io/v1beta2&quot;kind: SparkApplicationmetadata: name: spark-pi namespace: sparkspec: type: Scala mode: cluster image: &quot;registry.cn-hangzhou.aliyuncs.com/yudayu/spark:v3.1.1&quot; # 1gcr.io/spark-operator/spark:v3.1.1需要更换镜像，gcr.io目前国内无法访问。可以先对docker挂代理，pull到阿里云镜像后 imagePullPolicy: IfNotPresent mainClass: org.apache.spark.examples.SparkPi mainApplicationFile: &quot;local:///opt/spark/examples/jars/spark-examples_2.12-3.1.1.jar&quot; # 需要更换自己的jar包，local指该jar位于image内，可换成所有节点都能访问的web路径，或者通过指定nas挂载pv，将jar包放在nas的pv里 sparkVersion: &quot;3.1.1&quot; restartPolicy: type: Never volumes: - name: &quot;test-volume&quot; hostPath: path: &quot;/tmp&quot; type: Directory driver: cores: 1 coreLimit: &quot;1200m&quot; memory: &quot;512m&quot; labels: version: 3.1.1 serviceAccount: spark volumeMounts: - name: &quot;test-volume&quot; mountPath: &quot;/tmp&quot; executor: cores: 1 instances: 2 memory: &quot;512m&quot; labels: version: 3.1.1 volumeMounts: - name: &quot;test-volume&quot; mountPath: &quot;/tmp&quot; 部署一个Spark计算任务 1kubectl apply -f spark-pi.yaml 运维 123kubectl get sparkapplicationskubectl describe sparkapplicationskubectl get svc # 查看该任务的spark ui 12.2 安装 Spark On K8S 12345helm repo add bitnami https://charts.bitnami.com/bitnami# 注意是否存在 spark-operator 命名空间，没有则创建kubectl create ns spark-on-k8shelm install -n spark-on-k8s spark bitnami/spark \\ --set worker.coreLimit=28 12345678910./bin/spark-submit \\ --class org.apache.spark.examples.SparkPi \\ --conf spark.kubernetes.container.image=bitnami/spark:3 \\ --master k8s://https://125.220.153.23:6443 \\ --conf spark.kubernetes.driverEnv.SPARK_MASTER_URL=spark://10.97.43.141:7077 \\--deploy-mode cluster \\ --executor-memory 20G \\ --num-executors 10 \\--conf spark.executor.instances=5 \\https:///data/spark-examples_2.12-3.3.0.jar 1000 123456kubectl run --namespace spark-on-k8s spark-oge --rm --tty -i --restart=&#x27;Never&#x27; \\--image bitnami/spark:3 \\-- spark-submit --master spark://10.97.43.141:7077 \\--class org.apache.spark.examples.SparkPi \\ --deploy-mode cluster \\/data/spark-examples_2.12-3.3.0.jar 100000 13 在K8S上部署redis集群 待更 14 在K8S上部署nginx 14.1 创建pv 1vim nginx-pv.yaml 1234567891011121314apiVersion: v1kind: PersistentVolumemetadata: name: nginx-ydy-pv namespace: ydyspec: capacity: storage: 10Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain storageClassName: manual hostPath: path: /mnt/storage/k8s/pv/ydy-nginx-pvc 14.2 创建pvc 1vim nginx-pvc.yaml 123456789101112apiVersion: v1kind: PersistentVolumeClaimmetadata: name: nginx-ydy-pvc namespace: ydyspec: accessModes: - ReadWriteOnce resources: requests: storage: 10Gi storageClassName: manual 14.3 安装nginx并设置静态资源挂载的pvc 将nginx中的/app挂载到/mnt/storage/k8s/pv/luluancheng-nginx-pvc下 12helm install -n ydy nginx bitnami/nginx \\--set staticSitePVC=nginx-ydy-pvc 附录：疑难问题解决： 1 K8S强制删除 namespace（会删除该命名空间中的所有 pod ） 123#1、将该分区导出为json文件，以 oge namespace为例kubectl get ns oge -o json &gt; oge.json#2、编辑该json文件，将spec内的内容全部删除，然后保存退出 12# 3、另开一个终端，启动一个proxykubectl proxy --port=8081 12# 4、执行一个curl命令，更新oge namespacecurl -k -H &quot;Content-Type: application/json&quot; -X PUT --data-binary @oge.json http://127.0.0.1:8081/api/v1/namespaces/oge/finalize 2 CNI网络错误 当迁移集群之后，拉取镜像报cni网络错误，如下： 从上面的截图中看到问题出现在给Pod分配IP上，意思是 cni0 的IP不同于``10.244.9.1/24，下面我们使用 ifconfig`命令查看IP信息 从上面的图中我们可以看到``flannel.1的 **IP** 为10.244.9.0，然后我们又使用cat /run/flannel/subnet.env`，该文件内容如下： 其实现在的问题就比较明确了，我们使用的Overlay network为Flannel，也就是说Pod的IP地址段应该在Flannel的subnet下，而现在我们看到cni0的IP地址段与flannel subnet地址段不同，所以就出现了问题。 解决方案 方法1是将 cni0 的 IP 段修改为``10.244.9.1` 方法2是将这个错误的网卡删除掉，之后会自动重建 123# 下面我们删除错误的cni0，然后让它自己重建ifconfig cni0 downip link delete cni0 3 28 服务器增加路由（为了让两台刀片上网） 28上执行 12iptables -t nat -A POSTROUTING -s 192.168.0.209/24 -o em1_2 -j MASQUERADEiptables -t nat -A POSTROUTING -s 192.168.0.177/24 -o em1_2 -j MASQUERADE 4 异常断电等导致 etcd 心跳检测出现问题 Kubernetes API Server cannot be started after improper reboot K8S: etcd 集群备份灾难恢复操作手册 5 OpenStack服务器网络跳转镜像 作用: 保证OpenStack上服务器与实验室服务器可以 ping 通 IP 115.156.91.250 网关 115.156.91.254 子网掩码 255.255.255.0","categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"K8S","slug":"K8S","permalink":"https://binwenwu.github.io/tags/K8S/"},{"name":"Containerd","slug":"Containerd","permalink":"https://binwenwu.github.io/tags/Containerd/"}]},{"title":"VMware安装CentOS 7","slug":"VMware安装CentOS 7","date":"2023-08-04T08:59:05.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/7ddf46fc/","link":"","permalink":"https://binwenwu.github.io/posts/7ddf46fc/","excerpt":"","text":"0 准备工作 CentOS 操作系统镜像文件下载：https://mirrors.aliyun.com 1 新建虚拟机 2 选择自定义安装 3 硬件兼容性选择 选择与VMware相匹配的版本，点击下一步 4 选择稍后安装操作系统 5 选择要安装的操作系统 6 给虚拟机起名并选择它安装在什么位置 7 选择处理器配置 8 设置内存大小 9 网络类型选择NAT 10 I/O控制器类型，默认即可 11 磁盘类型，默认即可 12 创建磁盘 13 磁盘分配 14 指定磁盘文件，默认即可 15 新建虚拟机完成 16 安装CentOS镜像 点击编辑虚拟机配置 选择CD/DVD 找到下载好的iso镜像路径放进去，点击确定 开启虚拟机 上下箭头可选择 ↑ 选中 Install CentOS7，回车 选择语言，点击继续 软件安装选择最小化安装 创建分区 点击安装位置 选择我要配置分区，然后点击完成 选择标准分区，然后点击 + 添加分区 /boot分区就是操作系统的内核及在引导过程中使用的文件 Swap分区在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用 剩下的空间全部给根分区/，然后点击完成 点击接受更改 下面进行网络配置 点击配置，按如下更改，然后点击保存，并设置主机名 点击开始安装，安装过程中可以设置root的密码 安装完成后，设置网卡，让虚拟机可以上网 点击编辑 → 虚拟网络编辑器 点击更改设置 根据下图进行配置 应用，然后点击确定，现在就可以正常使用了 17 配置静态IP 打开命令行，输入 网卡默认名称不一定为ens33，需要自行查看 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 修改配置文件内容 重启网络服务 1service network restart","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://binwenwu.github.io/tags/CentOS/"},{"name":"VMware","slug":"VMware","permalink":"https://binwenwu.github.io/tags/VMware/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://binwenwu.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"Centos安装Grass","slug":"Centos安装Grass","date":"2023-08-03T14:04:51.000Z","updated":"2025-05-17T05:51:06.587Z","comments":true,"path":"posts/4e1214ce/","link":"","permalink":"https://binwenwu.github.io/posts/4e1214ce/","excerpt":"","text":"1 方案一：通过 EPEL 源安装（Centos 8） 1.1 安装 EPEL8 源 链接：https://grass.osgeo.org/download/linux/#GRASS-GIS-current 安装 EPEL8 源步骤：参考链接：https://blog.csdn.net/Lcongming/article/details/115983236 首先切换到yum仓库源的目录 1cd /etc/yum.repos.d/ 创建文件 12345678touch epel8.repo# 文件内容如下：[EPEL]name=EPELbaseurl=https://mirrors.cloud.tencent.com/epel/8/Everything/x86_64/ gpgcheck=0# 需要确保这个链接能打开# epel7用这个：https://mirrors.cloud.tencent.com/epel/7/x86_64/ 执行 yum repolist 读取查看结果，已经都可以读取了 1yum repolist 1.2 查看软件库中是否包含 GRASS 1yum search grass 1.3 安装 GRASS 1yum install grass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140Error: Package: wxBase3-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)Error: Package: grass-7.8.7-1.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.21)(64bit)Error: Package: xerces-c-3.2.3-5.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: hdf-4.2.14-5.el8.x86_64 (EPEL) Requires: libtirpc.so.3(TIRPC_0.3.0)(64bit)Error: Package: wxGTK3-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: grass-libs-7.8.7-1.el8.x86_64 (EPEL) Requires: libpng16.so.16(PNG16_0)(64bit)Error: Package: wxBase3-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.8)(64bit)Error: Package: PDAL-libs-2.1.0-8.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.21)(64bit)Error: Package: wxBase3-3.0.4-11.el8.x86_64 (EPEL) Requires: libc.so.6(GLIBC_2.28)(64bit)Error: Package: grass-7.8.7-1.el8.x86_64 (EPEL) Requires: libm.so.6(GLIBC_2.27)(64bit)Error: Package: wxGTK3-gl-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: grass-7.8.7-1.el8.x86_64 (EPEL) Requires: libreadline.so.7()(64bit)Error: Package: PDAL-libs-2.1.0-8.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.8)(64bit)Error: Package: python3-wxpython4-4.0.7-13.el8.x86_64 (EPEL) Requires: python3-wx-siplib-api(12)(x86-64) &gt;= 12.7Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.21)(64bit)Error: Package: python3-wxpython4-4.0.7-13.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.21)(64bit)Error: Package: grass-libs-7.8.7-1.el8.x86_64 (EPEL) Requires: libpng16.so.16()(64bit)Error: Package: PDAL-libs-2.1.0-8.el8.x86_64 (EPEL) Requires: libc.so.6(GLIBC_2.27)(64bit)Error: Package: proj-6.3.2-4.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.8)(64bit)Error: Package: PDAL-2.1.0-8.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)Error: Package: libbsd-0.11.7-2.el8.x86_64 (EPEL) Requires: libc.so.6(GLIBC_2.25)(64bit)Error: Package: python3-wxpython4-4.0.7-13.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libm.so.6(GLIBC_2.27)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libjson-c.so.4(JSONC_0.14)(64bit)Error: Package: xerces-c-3.2.3-5.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.8)(64bit)Error: Package: hdf5-1.10.5-4.el8.x86_64 (EPEL) Requires: libm.so.6(GLIBC_2.27)(64bit)Error: Package: wxGTK3-3.0.4-11.el8.x86_64 (EPEL) Requires: libpng16.so.16(PNG16_0)(64bit)Error: Package: hdf5-1.10.5-4.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: PDAL-2.1.0-8.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.21)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)Error: Package: grass-libs-7.8.7-1.el8.x86_64 (EPEL) Requires: libm.so.6(GLIBC_2.23)(64bit)Error: Package: ogdi-4.1.0-1.el8.x86_64 (EPEL) Requires: libtirpc.so.3()(64bit)Error: Package: grass-7.8.7-1.el8.x86_64 (EPEL) Requires: libpng16.so.16(PNG16_0)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libjson-c.so.4()(64bit)Error: Package: wxGTK3-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)Error: Package: PDAL-libs-2.1.0-8.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.22)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libpoppler.so.104()(64bit)Error: Package: xerces-c-3.2.3-5.el8.x86_64 (EPEL) Requires: libm.so.6(GLIBC_2.27)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: python3-wxpython4-4.0.7-13.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.8)(64bit)Error: Package: wxGTK3-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.8)(64bit)Error: Package: grass-7.8.7-1.el8.x86_64 (EPEL) Requires: python3-dateutilError: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libcfitsio.so.7()(64bit) Available: cfitsio-3.47-1.el8.x86_64 (EPEL) libcfitsio.so.7()(64bit) Installed: cfitsio-3.370-10.el7.x86_64 (@epel) ~libcfitsio.so.2()(64bit)Error: Package: hdf-4.2.14-5.el8.x86_64 (EPEL) Requires: libtirpc.so.3()(64bit)Error: Package: proj-6.3.2-4.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)Error: Package: netcdf-4.7.0-2.el8.x86_64 (EPEL) Requires: libtirpc.so.3()(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libdap.so.25()(64bit)Error: Package: ogdi-4.1.0-1.el8.x86_64 (EPEL) Requires: libtirpc.so.3(TIRPC_0.3.0)(64bit)Error: Package: PDAL-libs-2.1.0-8.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)Error: Package: python3-wxpython4-4.0.7-13.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.8)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libpng16.so.16(PNG16_0)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libgif.so.7()(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libjasper.so.4()(64bit)Error: Package: proj-epsg-4.8.0-4.el7.x86_64 (@epel) Requires: proj = 4.8.0-4.el7 Removing: proj-4.8.0-4.el7.x86_64 (@epel) proj = 4.8.0-4.el7 Updated By: proj-6.3.2-4.el8.x86_64 (EPEL) proj = 6.3.2-4.el8Error: Package: proj-nad-4.8.0-4.el7.x86_64 (@epel) Requires: proj = 4.8.0-4.el7 Removing: proj-4.8.0-4.el7.x86_64 (@epel) proj = 4.8.0-4.el7 Updated By: proj-6.3.2-4.el8.x86_64 (EPEL) proj = 6.3.2-4.el8Error: Package: grass-7.8.7-1.el8.x86_64 (EPEL) Requires: libhistory.so.7()(64bit)Error: Package: wxBase3-3.0.4-11.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: gdal-libs-3.0.4-11.el8.x86_64 (EPEL) Requires: libpng16.so.16()(64bit)Error: Package: arpack-3.7.0-1.el8.x86_64 (EPEL) Requires: libm.so.6(GLIBC_2.27)(64bit)Error: Package: proj-6.3.2-4.el8.x86_64 (EPEL) Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)Error: Package: proj-6.3.2-4.el8.x86_64 (EPEL) Requires: libstdc++.so.6(GLIBCXX_3.4.21)(64bit)Error: Package: grass-7.8.7-1.el8.x86_64 (EPEL) Requires: libpng16.so.16()(64bit)Error: Package: wxGTK3-3.0.4-11.el8.x86_64 (EPEL) Requires: libpng16.so.16()(64bit) 直接 yum 安装 grass 会存在依赖错误的问题，先看报错缺的是什么包，然后通过rpm的方式先把缺的包装好，所有缺的包安装完毕后，就可以通过yum install grass完成grass的安装，缺的包可以在这个网站上找：https://pkgs.org/ 假设缺的包是下面这个： 点进去，查看这个包的下载地址： 然后通过rpm命令安装这个包：rpm -Uvh 包的URL 1234# rpm -Uvh 包的URLrpm -Uvh https://vault.centos.org/centos/8/BaseOS/x86_64/os/Packages/glibc-2.28-164.el8.x86_64.rpm# 强制安装，忽略依赖错误# rpm -Uvh https://vault.centos.org/centos/8/BaseOS/x86_64/os/Packages/glibc-2.28-164.el8.x86_64.rpm --force --nodeps 参考资料：https://blog.csdn.net/fancy_xunbei/article/details/6268441 2 方案二：源码编译安装 参考链接：https://www.zhihu.com/zvideo/1496911384683773952 下载安装包 解压并进入 开始编译 1./configure --prefix=/home/oge/oge-grass 疑难杂症 GRASS需要针对 zstd 进行编译和链接。查看您尝试的命令(yum install zstd-devel)，我假设您使用的是RHEL/CentOS7。在CentOS存储库中没有zstd的包-您需要从EPEL安装它。它应该看起来像这样 1yum install libzstd-devel 123whereis gdal-config# 然后再在编译时指定依赖的位置./configure --with-gdal=/usr/local/bin/gdal-config --prefix=/home/oge/oge-grass 1yum install PNG-devel 1yum install fftw-devel 1yum install cairo-devel 1yum install freetype-devel … 3 方案三： Docker镜像方式安装 (推荐) grass docker 镜像：https://grass.osgeo.org/download/docker/ 创建容器","categories":[{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/categories/GIS/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/tags/GIS/"},{"name":"遥感","slug":"遥感","permalink":"https://binwenwu.github.io/tags/%E9%81%A5%E6%84%9F/"},{"name":"软件安装","slug":"软件安装","permalink":"https://binwenwu.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"Linux安装Clash – 代理 – VPN","slug":"Linux安装Clash – 代理 – VPN","date":"2023-08-01T10:25:15.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/438a2103/","link":"","permalink":"https://binwenwu.github.io/posts/438a2103/","excerpt":"","text":"1 什么是Clash? Clash 是一个跨平台的基于规则的代理实用程序，运行在网络和应用层，支持开箱即用的各种代理和反审查协议。 Clash 的使用对普通用户来说可能具有挑战性。那些可能想考虑改用 GUI 客户端，我们确实有一些建议： Windows 版 Clash（Windows 和 macOS） 安卓版 Clash ClashX 或者 ClashX Pro (macOS) 2 安装Linux Clash 2.1 下载Clash 下载链接：https://github.com/Dreamacro/clash/releases 2.2 上传至Linux服务器 创建文件夹 1mkdir /opt/clash &amp;&amp; cd /opt/clash 上传或移动 1mv clash-linux-386-v1.16.0 /opt/clash/clash 2.3 解压Clash 1gunzip clash-linux-386-v1.16.0.gz 2.4 文件夹授权 1chmod +x clash 3 设置Clash的配置 注：clash默认读取的配置文件位置在：~/.config/clash/ 3.1 设置配置文件 创建一个文件夹：放置我们的Clash配置文件 1mkdir ~/.config/clash/ &amp;&amp; cd ~/.config/clash/ 获取配置文件 如果没法直接下载，从PC电脑获取到Windows本地Clash的yaml、mmdb文件放到服务器的./config/clash/下面亦可，yaml文件命名为config.yaml、mmdb文件命名为：Country.mmdb 12sudo wget -O config.yaml &quot;yaml下载链接&quot;sudo wget -O XXX.mmdb &quot;mmdb下载链接&quot; yaml 文件大致内容如： 123456789mixed-port: 7890allow-lan: truebind-address: &#x27;*&#x27;mode: rulelog-level: infoexternal-controller: &#x27;127.0.0.1:9090&#x27;dns: enable: true ...... 4 启动服务 直接启动我们的./clash即可 123456[root@VM-4-12-centos clash]# ./clash INFO[0000] Start initial compatible provider 自动选择 INFO[0000] Start initial compatible provider FreeGecko INFO[0000] Start initial compatible provider 故障转移 INFO[0000] RESTful API listening at: 127.0.0.1:34567 INFO[0000] Mixed(http+socks) proxy listening at: [::]:7890","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"https://binwenwu.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/tags/Linux/"},{"name":"Clash","slug":"Clash","permalink":"https://binwenwu.github.io/tags/Clash/"},{"name":"VPN","slug":"VPN","permalink":"https://binwenwu.github.io/tags/VPN/"}]},{"title":"本地启动前端打包的项目","slug":"本地启动前端打包的项目","date":"2023-07-12T09:59:05.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/16380ff0/","link":"","permalink":"https://binwenwu.github.io/posts/16380ff0/","excerpt":"","text":"1 全局安装live-server插件 1npm install -g live-server 2 启动服务 在dist/build文件夹中终端输入 1live-server","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://binwenwu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://binwenwu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"打包","slug":"打包","permalink":"https://binwenwu.github.io/tags/%E6%89%93%E5%8C%85/"}]},{"title":"K8S集群环境搭建(Docker作为容器)","slug":"K8S集群环境搭建(Docker作为容器)","date":"2023-05-18T06:08:12.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/d862c611/","link":"","permalink":"https://binwenwu.github.io/posts/d862c611/","excerpt":"","text":"本文参考：https://zhuanlan.zhihu.com/p/558014199?utm_id=0 1. 安装Docker 1.1 安装docker 20.10.7 注意 Docker 版本，要和 Kubernetes 版本 有对应关系 三台机器上执行 1234567891011121314151617181920# 安装/更新 yum-utilsyum install -y yum-utils# 配置 yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 安装 docker 20.10.7 版本yum -y install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io# 查看 docker 版本docker -v# 启动 dockersystemctl start docker# 设置开机自启systemctl enable docker# 查看 docker 是否成功, 有 Client 和 Server 即成功docker version 1.2 配置加速镜像 三台机器上执行 12345678910111213141516171819sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://82m9ar63.mirror.aliyuncs.com&quot;], &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;], &quot;log-driver&quot;: &quot;json-file&quot;, &quot;log-opts&quot;: &#123; &quot;max-size&quot;: &quot;100m&quot; &#125;, &quot;storage-driver&quot;: &quot;overlay2&quot;&#125;EOF# 重启docker的后台线程sudo systemctl daemon-reload# 重启docker服务sudo systemctl restart docker# 查看是否配置成功docker info 2. 安装Kubernetes 每台机器2GB或者更多的RAM(如果少于这个数字 将会影响应用的运行内存) CPU2核以上 集群中所有的服务器的网络彼此可以相互连接。 关闭防火墙 12systemctl stop firewalld NetworkManagersystemctl disable firewalld NetworkManager 2.1 设置hostname 12345678910# 查看主机名hostname# 设置主机名hostnamectl set-hostname k8s-masterhostnamectl set-hostname k8s-node1hostnamectl set-hostname k8s-node2# 更新bash 2.2 关闭交换区 三台机器上执行 下面是一些安全设置 12345678910111213141516171819202122# 查看 交换分区free -m# 将 SELinux 设置为 permissive 模式（相当于将其禁用） 第一行是临时禁用，第二行是永久禁用setenforce 0sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config# 关闭swap；第一行是临时禁用，第二行是永久禁用swapoff -a sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab# 允许 iptables 检查桥接流量 （K8s 官方要求）cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confbr_netfilterEOFcat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 让配置生效sysctl --system 2.3 安装K8S三大件 安装 kubelet、kebeadm、kubectl；注意版本 (1.20.9) 三台机器上执行 1234567891011# 配置 k8s 的 yum 源地址cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 123456789# 安装 kubelet、kubeadm、kubectlyum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes# 启动kubeletsystemctl enable --now kubelet# 查看 kubelet 状态：一会停止 一会运行。 这个状态是对的，kubelet 等待 kubeadm 发号指令。systemctl status kubelet 2.4 使用kubeadm引导集群 下载各个机器需要的镜像,三台机器都要安装 12345678910111213141516171819# 配置镜像，生成 images.shsudo tee ./images.sh &lt;&lt;-&#x27;EOF&#x27;#!/bin/bashimages=(kube-apiserver:v1.20.9kube-proxy:v1.20.9kube-controller-manager:v1.20.9kube-scheduler:v1.20.9coredns:1.7.0etcd:3.4.13-0pause:3.2)for imageName in $&#123;images[@]&#125; ; dodocker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageNamedoneEOF# 拉取镜像chmod +x ./images.sh &amp;&amp; ./images.sh 使用docker images 查看 2.5 初始化主节点，即把看 k8s-master 变为主节点 三台机器上执行 123# 所有机器添加 master 域名映射，以下 IP 为 master 的 IP；# 访问 k8s-master 即 访问 192.168.1.135echo &quot;192.168.1.135 k8s-master&quot; &gt;&gt; /etc/hosts master节点上执行 1234567891011# 主节点初始化 （只在 master 服务器执行， 其他 node 不用）# --apiserver-advertise-address: master 的 IP# --control-plane-endpoint: master 的域名# --service-cidr 和 --pod-network-cidr 是网络范围，雷神 建议不要改。要改的话 2 个cidr 和 vps（192.168.x.x） 的，3 个网络互相不能重叠；还要修改 calico.yaml的 IP（下图有写）。kubeadm init \\--apiserver-advertise-address=192.168.1.135 \\--control-plane-endpoint=k8s-master \\--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \\--kubernetes-version v1.20.9 \\--service-cidr=10.96.0.0/16 \\--pod-network-cidr=192.168.0.0/16 出现这个即成功了 2.5 根据提示继续 master成功后提示 123456789101112131415161718192021222324252627Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configAlternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.confYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of control-plane nodes by copying certificate authoritiesand service account keys on each node and then running the following as root: kubeadm join k8s-master:6443 --token is7ewi.nznlk1wdhsaocmp1 \\ --discovery-token-ca-cert-hash sha256:b2795fca75bab316c566e98a619a3ce9b18c418e978c7b8fa9c48ff4143fd3c5 \\ --control-planeThen you can join any number of worker nodes by running the following on each as root:kubeadm join k8s-master:6443 --token is7ewi.nznlk1wdhsaocmp1 \\ --discovery-token-ca-cert-hash sha256:b2795fca75bab316c566e98a619a3ce9b18c418e978c7b8fa9c48ff4143fd3c5 To start using your cluster, you need to run the following as a regular user: 要开始使用集群，您需要以普通用户身份运行以下命令(master节点执行）：源自上面的提示 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 2.6 安装网络组件（calico） 注：只在 master 服务执行。其他 node 服务器 不用。 在master上执行 12345# 下载 calico.yamlcurl https://docs.projectcalico.org/manifests/calico.yaml -O# 加载配置kubectl apply -f calico.yaml 或者（这个更不会出错） 1kubectl apply -f https://docs.projectcalico.org/v3.18/manifests/calico.yaml 下载完成后生成calico.yaml 或者安装flannel 1kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml 注意 123如果修改了 初始化主节点中的--pod-network-cidr=192.168.0.0/16将 calico.yaml 的配置， # 去掉，IP 写 改的 IP。 2.7 Worker 加入集群 worker节点加入到集群中（源自提示） 12kubeadm join k8s-master:6443 --token is7ewi.nznlk1wdhsaocmp1 \\ --discovery-token-ca-cert-hash sha256:b2795fca75bab316c566e98a619a3ce9b18c418e978c7b8fa9c48ff4143fd3c5 出现这个即成功 2.8 每次重启需要先启动docker，否则k8s无法启动 2.9 令牌过期 在master主节点执行 12# 重新获取令牌kubeadm token create --print-join-command 2.10 部署Dashboard 参考链接: kubernetes(k8s)部署Dashboard - 干货分享 - 代码森林 (codeforest.cn) 2.10.1 运行pod（创建资源） 部署 dashboard（可视化页面）, kubernetes 官方提供的可视化界面 在master上执行，推荐下载到本地导入虚拟机 12# 根据 在线配置文件 创建资源kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml 12# 本地配置kubectl apply -f recommended.yaml 2.10.2 设置访问端口 12345# 修改配置文件 找到 type，将 ClusterIP 改成 NodePortkubectl edit svc kubernetes-dashboard -n kubernetes-dashboard# 找到端口，在安全组放行kubectl get svc -A |grep kubernetes-dashboard 32499即为访问端口，以后只需要使用任一节点的ip+32499即可访问 https://192.168.1.135:32499 （要注意是 https，port 是映射的端口，在配置文件查看） 3 疑难杂症 3.1 删除现有的dashboard服务 1kubectl delete service kubernetes-dashboard --namespace=kubernetes-dashboard 根据yaml来删除 1kubectl delete -f recommended.yaml 若资源下载不下来，则直接本地导入recommended.yaml ，下载地址如下 https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml 执行: 1kubectl apply -f recommended.yaml 3.2 dashboard启动失败（无法访问） 修改了 NodePort 后，Pod kubernetes-dashboard 起不来了。（环境：虚拟机） 12# 查看日志kubectl logs -f -n kubernetes-dashboard kubernetes-dashboard-658485d5c7-f89v7 解决思路 121、将 dashboard 部署到 master上，因为 master 刚安装了网络组件2、让 工作节点 也能访问 apiServer 方案1 先卸载原来的 dashboard 12# 无法访问，查看 部署到 哪个 node 上了， 将 dashboard 部署到 master 上kubectl get pods -A -o wide 1# 修改 recommended.yaml，添加下面 1234567# 重新安装 dashboard# 修改配置文件 找到 type，将 ClusterIP 改成 NodePortkubectl edit svc kubernetes-dashboard -n kubernetes-dashboard# 找到端口，在安全组放行kubectl get svc -A |grep kubernetes-dashboard 创建访问账号 12#创建访问账号，准备一个yaml文件vim dash-usr.yaml 文件内容如下 123456789101112131415161718apiVersion: v1kind: ServiceAccountmetadata: name: admin-user namespace: kubernetes-dashboard---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: admin-userroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard 1kubectl apply -f dash-usr.yaml 令牌访问 12#获取访问令牌kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=&quot;&#123;.secrets[0].name&#125;&quot;) -o go-template=&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot; 1eyJhbGciOiJSUzI1NiIsImtpZCI6IkZkbV91WkVqTnp3clZLd29JS1FYUWxURzZyd0FLcnpVQzBtRlRMTmpya0UifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLTVrbGtrIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJiNWVhYjQ2MS0xNjE1LTQ5ZTQtYTAzNC0wY2MxYWM1YTI5ODkiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.eum4COcUzn6wt_vOpCUUEiNENzeGUTC_ZlKeB8d0IplFlZWrAav3RbqV5LMDRRIyyZ-7csJb3COhFEiCRtlkc9MM60od4IRMscNxv_tm11A32pmGn9eFERyaYjKUFBHZfF34jPcsjYqU50TDn6wykI_B6r9ZzvpJemR-wqF2y-GBvmz8q19D9q5zlhaE9gmmvksEx-D0ZyOeZo4tMdbD757OdTjgzlYhmTpfTs-Z8-sdKWnHGFCYbAPzrEgMgChcIjlyDle9-JaE1WCosGCA73xsBzXNnkvYC7YB_tagX4BhGDZEu4eyRNbgCAqO6of6QnvDXvlesd59IU-WMVE-7Q 将令牌复制到token处 登录成功","categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"K8S","slug":"K8S","permalink":"https://binwenwu.github.io/tags/K8S/"}]},{"title":"Docker修改容器映射主机端口","slug":"Docker修改容器映射主机端口","date":"2023-05-12T07:26:51.000Z","updated":"2025-05-17T05:51:06.588Z","comments":true,"path":"posts/9c5d9ac5/","link":"","permalink":"https://binwenwu.github.io/posts/9c5d9ac5/","excerpt":"","text":"1 对于已经存在的容器，更改端口 停止容器 将容器打包成镜像 1docker commit 4f4561192346 wbw-geoserver:0.1（自定义镜像名:自定版本号） 通过新镜像开启新容器 12345docker run -d --name wbw-geoserver -p 31520:8080 wbw-geoserver:0.1#-d ——&gt;后台启动#-p ——&gt;主机端口：容器端口","categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://binwenwu.github.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"Docker安装配置","slug":"Docker安装配置","date":"2023-05-11T01:20:52.000Z","updated":"2025-05-17T05:51:06.588Z","comments":true,"path":"posts/b035bcd6/","link":"","permalink":"https://binwenwu.github.io/posts/b035bcd6/","excerpt":"","text":"1 安装docker 20.10.7 注意 Docker 版本，要和 Kubernetes 版本 有对应关系 1234567891011121314151617# 安装/更新 yum-utilsyum install -y yum-utils# 配置 yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 安装 docker 20.10.7 版本yum -y install docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io# 查看 docker 版本docker -v# 启动 dockersystemctl start docker# 查看 docker 是否成功, 有 Client 和 Server 即成功docker version 2 配置加速镜像 12345678910111213141516171819202122sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot; : [ &quot;https://mirror.ccs.tencentyun.com&quot;, &quot;http://registry.docker-cn.com&quot;, &quot;http://docker.mirrors.ustc.edu.cn&quot;, &quot;http://hub-mirror.c.163.com&quot; ], &quot;insecure-registries&quot; : [ &quot;registry.docker-cn.com&quot;, &quot;docker.mirrors.ustc.edu.cn&quot; ], &quot;debug&quot; : true, &quot;experimental&quot; : true&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker# 查看是否配置成功docker info","categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://binwenwu.github.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"Linux配置NFS共享存储服务器","slug":"Linux配置NFS共享存储服务器","date":"2023-04-03T12:10:50.000Z","updated":"2025-05-17T05:51:06.589Z","comments":true,"path":"posts/d154fd87/","link":"","permalink":"https://binwenwu.github.io/posts/d154fd87/","excerpt":"","text":"1. 安装 nfs-untils 1yum -y install nfs-utils 2. 设置共享目录 12345678mkdir -p /data/publicDisk001# 授权chmod 777 /data/publicDisk001/# 修改文件，让10.0.0.0/24 这个网段的机器都能用vim /etc/exports/data/publicDisk001 10.0.0.0/24(rw,no_root_squash) 3. 启动广播和nfs 123456systemctl start rpcbind# 启动nfssystemctl start nfs# 若 centerOS8以上，则执行此命令启动 sudo service nfs-server start 4. 在同一网段下，另一个主机也安装 nfs 作为客户端 1234yum -y install nfs-utils# 启动nfssystemctl start nfssudo service nfs-server start 5. 挂载 12345# 新建目录mkdir -p /data/disk01# 挂载网盘到此路径mount -t nfs 10.0.0.204:/data/publicDisk001 /data/disk01 6. 查看挂载情况 1df -h","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/tags/Linux/"},{"name":"存储","slug":"存储","permalink":"https://binwenwu.github.io/tags/%E5%AD%98%E5%82%A8/"}]},{"title":"VMware虚拟机设置静态IP","slug":"VMware虚拟机设置静态IP","date":"2023-03-14T08:59:05.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/f5fad029/","link":"","permalink":"https://binwenwu.github.io/posts/f5fad029/","excerpt":"","text":"1、设置虚拟网关 点击导航栏上面的【编辑】–&gt;【虚拟网络编辑器】，并以【管理员】的身份打开虚拟机。 点击【VMnet8 NAT模式】，取消使用本地使用本地dhcp服务，配置网络段（子网ip段）为192.168.1.0，点击NAT设置。 配置【网关ip】，注意【网关ip】需要在【子网ip】段下，这里设置为192.168.1.2 2、配置虚拟机静态ip 打开命令行，输入 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 修改配置文件内容 1234567#ipIPADDR=192.168.1.136NETMASK=255.255.255.0#gatewayGATEWAY=192.168.1.2#DNSDNS1=114.114.114 注：DNS1是dns服务器，一般设置为114.114.114.114、114.114.115.115和8.8.8.8等(其他的也可以，只不过这几个用的人比较多而已) 3、检测配置是否成功 重启网络服务 1service network restart ping一下百度 1ping www.baidu.com","categories":[{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"https://binwenwu.github.io/tags/VMware/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://binwenwu.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"IP","slug":"IP","permalink":"https://binwenwu.github.io/tags/IP/"}]},{"title":"基于 MPI 的埃拉托斯特尼筛法的并行化设计、实现与结果分析","slug":"基于 MPI 的埃拉托斯特尼筛法的并行化设计、实现与结果分析","date":"2023-03-12T09:59:05.000Z","updated":"2025-05-17T05:51:06.590Z","comments":true,"path":"posts/55978286/","link":"","permalink":"https://binwenwu.github.io/posts/55978286/","excerpt":"","text":"1 算法介绍 ​ 埃拉托斯特尼是一位古希腊数学家，他在寻找整数N以内的素数时，采用了一种与众不同的方法：先将2～N的各个数写在纸上： ​ 在2的上面画一个圆圈，然后划去2的其他倍数；第一个既未画圈又没有被划去的数是3，将它画圈，再划去3的其他倍数；现在既未画圈又没有被划去的第一个数是5，将它画圈，并划去5的其他倍数……依此类推，一直到所有小于或等于Ｎ的各数都画了圈或划去为止。这时，画了圈的以及未划去的那些数正好就是小于Ｎ的素数。 其伪代码如下： 1234567891011Input: an integer n &gt; 1Let A be an array of Boolean values, indexed by integers 2 to n,initially all set to true. for i = 2, 3, 4, ..., not exceeding √n: if A[i] is true: for j = i2, i2+i, i2+2i, i2+3i, ..., not exceeding n : A[j] := falseOutput: all i such that A[i] is true. 2 实验环境 硬件环境 开发环境 Visual Studio 2019，MSMPI v10.0 3 MPI环境配置（Windows） windows 下运行mpi首推微软的msmp，因为比较简单，下载地址为：https://docs.microsoft.com/en-us/message-passing-interface/microsoft-mpi， 将两个安装包msmpisdk.msi和msmpisetup.exe分别下载然后安装完成后即可，下面是在VS2019中引入MSMPI的步骤： 在VS中新建C++控制台应用程序，将项目编译改为X64 去安装的SDK目录，找到include与lib文件夹右键项目 – 属性 – vc++ 目录中包含目录添加 include 文件夹路径，库目录中添加 lib 文件夹路径。 C/C++ -&gt;预处理器 -&gt; 预处理器定义 -&gt; 添加MPICH_SKIP_MPICXX C/C++ -&gt; 代码生成 -&gt; 运行库 -&gt;选择：多线程调试(/MTD) 属性 – 链接器 – 输入 – 附加依赖项中添加msmpi.lib; 4 Linux下配置MPICH 安装 1sudo apt-get install mpic CmakeLists.txt 下配置 12345678cmake_minimum_required(VERSION 3.13) project(MPI) set(CMAKE_CXX_STANDARD 17) find_package(MPI REQUIRED) include_directories($&#123;MPI_INCLUDE_PATH&#125;) set(CMAKE_CXX_COMPILER mpicxx) set(CMAKE_C_COMPILER mpicc) add_executable(MPI main.cpp) 5 源码及更多分析文档 Github源码https://github.com/binwenwu/Eratosthenes","categories":[{"name":"算法","slug":"算法","permalink":"https://binwenwu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://binwenwu.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://binwenwu.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"云原生","slug":"云原生","permalink":"https://binwenwu.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/categories/GIS/"},{"name":"后端开发","slug":"后端开发","permalink":"https://binwenwu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/categories/Linux/"},{"name":"日常办公","slug":"日常办公","permalink":"https://binwenwu.github.io/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"},{"name":"前端开发","slug":"前端开发","permalink":"https://binwenwu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"算法","permalink":"https://binwenwu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://binwenwu.github.io/tags/Docker/"},{"name":"CentOS","slug":"CentOS","permalink":"https://binwenwu.github.io/tags/CentOS/"},{"name":"GIS","slug":"GIS","permalink":"https://binwenwu.github.io/tags/GIS/"},{"name":"3DCityDB","slug":"3DCityDB","permalink":"https://binwenwu.github.io/tags/3DCityDB/"},{"name":"后端","slug":"后端","permalink":"https://binwenwu.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"gdal","slug":"gdal","permalink":"https://binwenwu.github.io/tags/gdal/"},{"name":"Bigtable","slug":"Bigtable","permalink":"https://binwenwu.github.io/tags/Bigtable/"},{"name":"Hbase","slug":"Hbase","permalink":"https://binwenwu.github.io/tags/Hbase/"},{"name":"Linux","slug":"Linux","permalink":"https://binwenwu.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://binwenwu.github.io/tags/SSH/"},{"name":"Postgres","slug":"Postgres","permalink":"https://binwenwu.github.io/tags/Postgres/"},{"name":"3DTiles","slug":"3DTiles","permalink":"https://binwenwu.github.io/tags/3DTiles/"},{"name":"yum","slug":"yum","permalink":"https://binwenwu.github.io/tags/yum/"},{"name":"存储","slug":"存储","permalink":"https://binwenwu.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"nginx","slug":"nginx","permalink":"https://binwenwu.github.io/tags/nginx/"},{"name":"数据库","slug":"数据库","permalink":"https://binwenwu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"容器","slug":"容器","permalink":"https://binwenwu.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"软件安装","slug":"软件安装","permalink":"https://binwenwu.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Office","slug":"Office","permalink":"https://binwenwu.github.io/tags/Office/"},{"name":"Windows","slug":"Windows","permalink":"https://binwenwu.github.io/tags/Windows/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://binwenwu.github.io/tags/PostgreSQL/"},{"name":"PostGIS","slug":"PostGIS","permalink":"https://binwenwu.github.io/tags/PostGIS/"},{"name":"Vue","slug":"Vue","permalink":"https://binwenwu.github.io/tags/Vue/"},{"name":"前端","slug":"前端","permalink":"https://binwenwu.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"组件","slug":"组件","permalink":"https://binwenwu.github.io/tags/%E7%BB%84%E4%BB%B6/"},{"name":"安装","slug":"安装","permalink":"https://binwenwu.github.io/tags/%E5%AE%89%E8%A3%85/"},{"name":"Pandoc","slug":"Pandoc","permalink":"https://binwenwu.github.io/tags/Pandoc/"},{"name":"K8S","slug":"K8S","permalink":"https://binwenwu.github.io/tags/K8S/"},{"name":"Containerd","slug":"Containerd","permalink":"https://binwenwu.github.io/tags/Containerd/"},{"name":"VMware","slug":"VMware","permalink":"https://binwenwu.github.io/tags/VMware/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://binwenwu.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"遥感","slug":"遥感","permalink":"https://binwenwu.github.io/tags/%E9%81%A5%E6%84%9F/"},{"name":"Clash","slug":"Clash","permalink":"https://binwenwu.github.io/tags/Clash/"},{"name":"VPN","slug":"VPN","permalink":"https://binwenwu.github.io/tags/VPN/"},{"name":"打包","slug":"打包","permalink":"https://binwenwu.github.io/tags/%E6%89%93%E5%8C%85/"},{"name":"IP","slug":"IP","permalink":"https://binwenwu.github.io/tags/IP/"},{"name":"并行计算","slug":"并行计算","permalink":"https://binwenwu.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://binwenwu.github.io/tags/%E7%AE%97%E6%B3%95/"}]}